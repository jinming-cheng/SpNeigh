[{"path":"https://github.com/jinming-cheng/SpNeigh/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"GNU General Public License","title":"GNU General Public License","text":"Version 3, 29 June 2007Copyright © 2007 Free Software Foundation, Inc. <http://fsf.org/> Everyone permitted copy distribute verbatim copies license document, changing allowed.","code":""},{"path":"https://github.com/jinming-cheng/SpNeigh/LICENSE.html","id":"preamble","dir":"","previous_headings":"","what":"Preamble","title":"GNU General Public License","text":"GNU General Public License free, copyleft license software kinds works. licenses software practical works designed take away freedom share change works. contrast, GNU General Public License intended guarantee freedom share change versions program–make sure remains free software users. , Free Software Foundation, use GNU General Public License software; applies also work released way authors. can apply programs, . speak free software, referring freedom, price. General Public Licenses designed make sure freedom distribute copies free software (charge wish), receive source code can get want , can change software use pieces new free programs, know can things. protect rights, need prevent others denying rights asking surrender rights. Therefore, certain responsibilities distribute copies software, modify : responsibilities respect freedom others. example, distribute copies program, whether gratis fee, must pass recipients freedoms received. must make sure , , receive can get source code. must show terms know rights. Developers use GNU GPL protect rights two steps: (1) assert copyright software, (2) offer License giving legal permission copy, distribute /modify . developers’ authors’ protection, GPL clearly explains warranty free software. users’ authors’ sake, GPL requires modified versions marked changed, problems attributed erroneously authors previous versions. devices designed deny users access install run modified versions software inside , although manufacturer can . fundamentally incompatible aim protecting users’ freedom change software. systematic pattern abuse occurs area products individuals use, precisely unacceptable. Therefore, designed version GPL prohibit practice products. problems arise substantially domains, stand ready extend provision domains future versions GPL, needed protect freedom users. Finally, every program threatened constantly software patents. States allow patents restrict development use software general-purpose computers, , wish avoid special danger patents applied free program make effectively proprietary. prevent , GPL assures patents used render program non-free. precise terms conditions copying, distribution modification follow.","code":""},{"path":[]},{"path":"https://github.com/jinming-cheng/SpNeigh/LICENSE.html","id":"id_0-definitions","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"0. Definitions","title":"GNU General Public License","text":"“License” refers version 3 GNU General Public License. “Copyright” also means copyright-like laws apply kinds works, semiconductor masks. “Program” refers copyrightable work licensed License. licensee addressed “”. “Licensees” “recipients” may individuals organizations. “modify” work means copy adapt part work fashion requiring copyright permission, making exact copy. resulting work called “modified version” earlier work work “based ” earlier work. “covered work” means either unmodified Program work based Program. “propagate” work means anything , without permission, make directly secondarily liable infringement applicable copyright law, except executing computer modifying private copy. Propagation includes copying, distribution (without modification), making available public, countries activities well. “convey” work means kind propagation enables parties make receive copies. Mere interaction user computer network, transfer copy, conveying. interactive user interface displays “Appropriate Legal Notices” extent includes convenient prominently visible feature (1) displays appropriate copyright notice, (2) tells user warranty work (except extent warranties provided), licensees may convey work License, view copy License. interface presents list user commands options, menu, prominent item list meets criterion.","code":""},{"path":"https://github.com/jinming-cheng/SpNeigh/LICENSE.html","id":"id_1-source-code","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"1. Source Code","title":"GNU General Public License","text":"“source code” work means preferred form work making modifications . “Object code” means non-source form work. “Standard Interface” means interface either official standard defined recognized standards body, , case interfaces specified particular programming language, one widely used among developers working language. “System Libraries” executable work include anything, work whole, () included normal form packaging Major Component, part Major Component, (b) serves enable use work Major Component, implement Standard Interface implementation available public source code form. “Major Component”, context, means major essential component (kernel, window system, ) specific operating system () executable work runs, compiler used produce work, object code interpreter used run . “Corresponding Source” work object code form means source code needed generate, install, (executable work) run object code modify work, including scripts control activities. However, include work’s System Libraries, general-purpose tools generally available free programs used unmodified performing activities part work. example, Corresponding Source includes interface definition files associated source files work, source code shared libraries dynamically linked subprograms work specifically designed require, intimate data communication control flow subprograms parts work. Corresponding Source need include anything users can regenerate automatically parts Corresponding Source. Corresponding Source work source code form work.","code":""},{"path":"https://github.com/jinming-cheng/SpNeigh/LICENSE.html","id":"id_2-basic-permissions","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"2. Basic Permissions","title":"GNU General Public License","text":"rights granted License granted term copyright Program, irrevocable provided stated conditions met. License explicitly affirms unlimited permission run unmodified Program. output running covered work covered License output, given content, constitutes covered work. License acknowledges rights fair use equivalent, provided copyright law. may make, run propagate covered works convey, without conditions long license otherwise remains force. may convey covered works others sole purpose make modifications exclusively , provide facilities running works, provided comply terms License conveying material control copyright. thus making running covered works must exclusively behalf, direction control, terms prohibit making copies copyrighted material outside relationship . Conveying circumstances permitted solely conditions stated . Sublicensing allowed; section 10 makes unnecessary.","code":""},{"path":"https://github.com/jinming-cheng/SpNeigh/LICENSE.html","id":"id_3-protecting-users-legal-rights-from-anti-circumvention-law","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"3. Protecting Users’ Legal Rights From Anti-Circumvention Law","title":"GNU General Public License","text":"covered work shall deemed part effective technological measure applicable law fulfilling obligations article 11 WIPO copyright treaty adopted 20 December 1996, similar laws prohibiting restricting circumvention measures. convey covered work, waive legal power forbid circumvention technological measures extent circumvention effected exercising rights License respect covered work, disclaim intention limit operation modification work means enforcing, work’s users, third parties’ legal rights forbid circumvention technological measures.","code":""},{"path":"https://github.com/jinming-cheng/SpNeigh/LICENSE.html","id":"id_4-conveying-verbatim-copies","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"4. Conveying Verbatim Copies","title":"GNU General Public License","text":"may convey verbatim copies Program’s source code receive , medium, provided conspicuously appropriately publish copy appropriate copyright notice; keep intact notices stating License non-permissive terms added accord section 7 apply code; keep intact notices absence warranty; give recipients copy License along Program. may charge price price copy convey, may offer support warranty protection fee.","code":""},{"path":"https://github.com/jinming-cheng/SpNeigh/LICENSE.html","id":"id_5-conveying-modified-source-versions","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"5. Conveying Modified Source Versions","title":"GNU General Public License","text":"may convey work based Program, modifications produce Program, form source code terms section 4, provided also meet conditions: ) work must carry prominent notices stating modified , giving relevant date. b) work must carry prominent notices stating released License conditions added section 7. requirement modifies requirement section 4 “keep intact notices”. c) must license entire work, whole, License anyone comes possession copy. License therefore apply, along applicable section 7 additional terms, whole work, parts, regardless packaged. License gives permission license work way, invalidate permission separately received . d) work interactive user interfaces, must display Appropriate Legal Notices; however, Program interactive interfaces display Appropriate Legal Notices, work need make . compilation covered work separate independent works, nature extensions covered work, combined form larger program, volume storage distribution medium, called “aggregate” compilation resulting copyright used limit access legal rights compilation’s users beyond individual works permit. Inclusion covered work aggregate cause License apply parts aggregate.","code":""},{"path":"https://github.com/jinming-cheng/SpNeigh/LICENSE.html","id":"id_6-conveying-non-source-forms","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"6. Conveying Non-Source Forms","title":"GNU General Public License","text":"may convey covered work object code form terms sections 4 5, provided also convey machine-readable Corresponding Source terms License, one ways: ) Convey object code , embodied , physical product (including physical distribution medium), accompanied Corresponding Source fixed durable physical medium customarily used software interchange. b) Convey object code , embodied , physical product (including physical distribution medium), accompanied written offer, valid least three years valid long offer spare parts customer support product model, give anyone possesses object code either (1) copy Corresponding Source software product covered License, durable physical medium customarily used software interchange, price reasonable cost physically performing conveying source, (2) access copy Corresponding Source network server charge. c) Convey individual copies object code copy written offer provide Corresponding Source. alternative allowed occasionally noncommercially, received object code offer, accord subsection 6b. d) Convey object code offering access designated place (gratis charge), offer equivalent access Corresponding Source way place charge. need require recipients copy Corresponding Source along object code. place copy object code network server, Corresponding Source may different server (operated third party) supports equivalent copying facilities, provided maintain clear directions next object code saying find Corresponding Source. Regardless server hosts Corresponding Source, remain obligated ensure available long needed satisfy requirements. e) Convey object code using peer--peer transmission, provided inform peers object code Corresponding Source work offered general public charge subsection 6d. separable portion object code, whose source code excluded Corresponding Source System Library, need included conveying object code work. “User Product” either (1) “consumer product”, means tangible personal property normally used personal, family, household purposes, (2) anything designed sold incorporation dwelling. determining whether product consumer product, doubtful cases shall resolved favor coverage. particular product received particular user, “normally used” refers typical common use class product, regardless status particular user way particular user actually uses, expects expected use, product. product consumer product regardless whether product substantial commercial, industrial non-consumer uses, unless uses represent significant mode use product. “Installation Information” User Product means methods, procedures, authorization keys, information required install execute modified versions covered work User Product modified version Corresponding Source. information must suffice ensure continued functioning modified object code case prevented interfered solely modification made. convey object code work section , , specifically use , User Product, conveying occurs part transaction right possession use User Product transferred recipient perpetuity fixed term (regardless transaction characterized), Corresponding Source conveyed section must accompanied Installation Information. requirement apply neither third party retains ability install modified object code User Product (example, work installed ROM). requirement provide Installation Information include requirement continue provide support service, warranty, updates work modified installed recipient, User Product modified installed. Access network may denied modification materially adversely affects operation network violates rules protocols communication across network. Corresponding Source conveyed, Installation Information provided, accord section must format publicly documented (implementation available public source code form), must require special password key unpacking, reading copying.","code":""},{"path":"https://github.com/jinming-cheng/SpNeigh/LICENSE.html","id":"id_7-additional-terms","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"7. Additional Terms","title":"GNU General Public License","text":"“Additional permissions” terms supplement terms License making exceptions one conditions. Additional permissions applicable entire Program shall treated though included License, extent valid applicable law. additional permissions apply part Program, part may used separately permissions, entire Program remains governed License without regard additional permissions. convey copy covered work, may option remove additional permissions copy, part . (Additional permissions may written require removal certain cases modify work.) may place additional permissions material, added covered work, can give appropriate copyright permission. Notwithstanding provision License, material add covered work, may (authorized copyright holders material) supplement terms License terms: ) Disclaiming warranty limiting liability differently terms sections 15 16 License; b) Requiring preservation specified reasonable legal notices author attributions material Appropriate Legal Notices displayed works containing ; c) Prohibiting misrepresentation origin material, requiring modified versions material marked reasonable ways different original version; d) Limiting use publicity purposes names licensors authors material; e) Declining grant rights trademark law use trade names, trademarks, service marks; f) Requiring indemnification licensors authors material anyone conveys material (modified versions ) contractual assumptions liability recipient, liability contractual assumptions directly impose licensors authors. non-permissive additional terms considered “restrictions” within meaning section 10. Program received , part , contains notice stating governed License along term restriction, may remove term. license document contains restriction permits relicensing conveying License, may add covered work material governed terms license document, provided restriction survive relicensing conveying. add terms covered work accord section, must place, relevant source files, statement additional terms apply files, notice indicating find applicable terms. Additional terms, permissive non-permissive, may stated form separately written license, stated exceptions; requirements apply either way.","code":""},{"path":"https://github.com/jinming-cheng/SpNeigh/LICENSE.html","id":"id_8-termination","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"8. Termination","title":"GNU General Public License","text":"may propagate modify covered work except expressly provided License. attempt otherwise propagate modify void, automatically terminate rights License (including patent licenses granted third paragraph section 11). However, cease violation License, license particular copyright holder reinstated () provisionally, unless copyright holder explicitly finally terminates license, (b) permanently, copyright holder fails notify violation reasonable means prior 60 days cessation. Moreover, license particular copyright holder reinstated permanently copyright holder notifies violation reasonable means, first time received notice violation License (work) copyright holder, cure violation prior 30 days receipt notice. Termination rights section terminate licenses parties received copies rights License. rights terminated permanently reinstated, qualify receive new licenses material section 10.","code":""},{"path":"https://github.com/jinming-cheng/SpNeigh/LICENSE.html","id":"id_9-acceptance-not-required-for-having-copies","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"9. Acceptance Not Required for Having Copies","title":"GNU General Public License","text":"required accept License order receive run copy Program. Ancillary propagation covered work occurring solely consequence using peer--peer transmission receive copy likewise require acceptance. However, nothing License grants permission propagate modify covered work. actions infringe copyright accept License. Therefore, modifying propagating covered work, indicate acceptance License .","code":""},{"path":"https://github.com/jinming-cheng/SpNeigh/LICENSE.html","id":"id_10-automatic-licensing-of-downstream-recipients","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"10. Automatic Licensing of Downstream Recipients","title":"GNU General Public License","text":"time convey covered work, recipient automatically receives license original licensors, run, modify propagate work, subject License. responsible enforcing compliance third parties License. “entity transaction” transaction transferring control organization, substantially assets one, subdividing organization, merging organizations. propagation covered work results entity transaction, party transaction receives copy work also receives whatever licenses work party’s predecessor interest give previous paragraph, plus right possession Corresponding Source work predecessor interest, predecessor can get reasonable efforts. may impose restrictions exercise rights granted affirmed License. example, may impose license fee, royalty, charge exercise rights granted License, may initiate litigation (including cross-claim counterclaim lawsuit) alleging patent claim infringed making, using, selling, offering sale, importing Program portion .","code":""},{"path":"https://github.com/jinming-cheng/SpNeigh/LICENSE.html","id":"id_11-patents","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"11. Patents","title":"GNU General Public License","text":"“contributor” copyright holder authorizes use License Program work Program based. work thus licensed called contributor’s “contributor version”. contributor’s “essential patent claims” patent claims owned controlled contributor, whether already acquired hereafter acquired, infringed manner, permitted License, making, using, selling contributor version, include claims infringed consequence modification contributor version. purposes definition, “control” includes right grant patent sublicenses manner consistent requirements License. contributor grants non-exclusive, worldwide, royalty-free patent license contributor’s essential patent claims, make, use, sell, offer sale, import otherwise run, modify propagate contents contributor version. following three paragraphs, “patent license” express agreement commitment, however denominated, enforce patent (express permission practice patent covenant sue patent infringement). “grant” patent license party means make agreement commitment enforce patent party. convey covered work, knowingly relying patent license, Corresponding Source work available anyone copy, free charge terms License, publicly available network server readily accessible means, must either (1) cause Corresponding Source available, (2) arrange deprive benefit patent license particular work, (3) arrange, manner consistent requirements License, extend patent license downstream recipients. “Knowingly relying” means actual knowledge , patent license, conveying covered work country, recipient’s use covered work country, infringe one identifiable patents country reason believe valid. , pursuant connection single transaction arrangement, convey, propagate procuring conveyance , covered work, grant patent license parties receiving covered work authorizing use, propagate, modify convey specific copy covered work, patent license grant automatically extended recipients covered work works based . patent license “discriminatory” include within scope coverage, prohibits exercise , conditioned non-exercise one rights specifically granted License. may convey covered work party arrangement third party business distributing software, make payment third party based extent activity conveying work, third party grants, parties receive covered work , discriminatory patent license () connection copies covered work conveyed (copies made copies), (b) primarily connection specific products compilations contain covered work, unless entered arrangement, patent license granted, prior 28 March 2007. Nothing License shall construed excluding limiting implied license defenses infringement may otherwise available applicable patent law.","code":""},{"path":"https://github.com/jinming-cheng/SpNeigh/LICENSE.html","id":"id_12-no-surrender-of-others-freedom","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"12. No Surrender of Others’ Freedom","title":"GNU General Public License","text":"conditions imposed (whether court order, agreement otherwise) contradict conditions License, excuse conditions License. convey covered work satisfy simultaneously obligations License pertinent obligations, consequence may convey . example, agree terms obligate collect royalty conveying convey Program, way satisfy terms License refrain entirely conveying Program.","code":""},{"path":"https://github.com/jinming-cheng/SpNeigh/LICENSE.html","id":"id_13-use-with-the-gnu-affero-general-public-license","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"13. Use with the GNU Affero General Public License","title":"GNU General Public License","text":"Notwithstanding provision License, permission link combine covered work work licensed version 3 GNU Affero General Public License single combined work, convey resulting work. terms License continue apply part covered work, special requirements GNU Affero General Public License, section 13, concerning interaction network apply combination .","code":""},{"path":"https://github.com/jinming-cheng/SpNeigh/LICENSE.html","id":"id_14-revised-versions-of-this-license","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"14. Revised Versions of this License","title":"GNU General Public License","text":"Free Software Foundation may publish revised /new versions GNU General Public License time time. new versions similar spirit present version, may differ detail address new problems concerns. version given distinguishing version number. Program specifies certain numbered version GNU General Public License “later version” applies , option following terms conditions either numbered version later version published Free Software Foundation. Program specify version number GNU General Public License, may choose version ever published Free Software Foundation. Program specifies proxy can decide future versions GNU General Public License can used, proxy’s public statement acceptance version permanently authorizes choose version Program. Later license versions may give additional different permissions. However, additional obligations imposed author copyright holder result choosing follow later version.","code":""},{"path":"https://github.com/jinming-cheng/SpNeigh/LICENSE.html","id":"id_15-disclaimer-of-warranty","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"15. Disclaimer of Warranty","title":"GNU General Public License","text":"WARRANTY PROGRAM, EXTENT PERMITTED APPLICABLE LAW. EXCEPT OTHERWISE STATED WRITING COPYRIGHT HOLDERS /PARTIES PROVIDE PROGRAM “” WITHOUT WARRANTY KIND, EITHER EXPRESSED IMPLIED, INCLUDING, LIMITED , IMPLIED WARRANTIES MERCHANTABILITY FITNESS PARTICULAR PURPOSE. ENTIRE RISK QUALITY PERFORMANCE PROGRAM . PROGRAM PROVE DEFECTIVE, ASSUME COST NECESSARY SERVICING, REPAIR CORRECTION.","code":""},{"path":"https://github.com/jinming-cheng/SpNeigh/LICENSE.html","id":"id_16-limitation-of-liability","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"16. Limitation of Liability","title":"GNU General Public License","text":"EVENT UNLESS REQUIRED APPLICABLE LAW AGREED WRITING COPYRIGHT HOLDER, PARTY MODIFIES /CONVEYS PROGRAM PERMITTED , LIABLE DAMAGES, INCLUDING GENERAL, SPECIAL, INCIDENTAL CONSEQUENTIAL DAMAGES ARISING USE INABILITY USE PROGRAM (INCLUDING LIMITED LOSS DATA DATA RENDERED INACCURATE LOSSES SUSTAINED THIRD PARTIES FAILURE PROGRAM OPERATE PROGRAMS), EVEN HOLDER PARTY ADVISED POSSIBILITY DAMAGES.","code":""},{"path":"https://github.com/jinming-cheng/SpNeigh/LICENSE.html","id":"id_17-interpretation-of-sections-15-and-16","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"17. Interpretation of Sections 15 and 16","title":"GNU General Public License","text":"disclaimer warranty limitation liability provided given local legal effect according terms, reviewing courts shall apply local law closely approximates absolute waiver civil liability connection Program, unless warranty assumption liability accompanies copy Program return fee. END TERMS CONDITIONS","code":""},{"path":"https://github.com/jinming-cheng/SpNeigh/LICENSE.html","id":"how-to-apply-these-terms-to-your-new-programs","dir":"","previous_headings":"","what":"How to Apply These Terms to Your New Programs","title":"GNU General Public License","text":"develop new program, want greatest possible use public, best way achieve make free software everyone can redistribute change terms. , attach following notices program. safest attach start source file effectively state exclusion warranty; file least “copyright” line pointer full notice found. Also add information contact electronic paper mail. program terminal interaction, make output short notice like starts interactive mode: hypothetical commands show w show c show appropriate parts General Public License. course, program’s commands might different; GUI interface, use “box”. also get employer (work programmer) school, , sign “copyright disclaimer” program, necessary. information , apply follow GNU GPL, see <http://www.gnu.org/licenses/>. GNU General Public License permit incorporating program proprietary programs. program subroutine library, may consider useful permit linking proprietary applications library. want , use GNU Lesser General Public License instead License. first, please read <http://www.gnu.org/philosophy/--lgpl.html>.","code":"<one line to give the program's name and a brief idea of what it does.> Copyright (C) <year>  <name of author>  This program is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program.  If not, see <http://www.gnu.org/licenses/>. <program>  Copyright (C) <year>  <name of author> This program comes with ABSOLUTELY NO WARRANTY; for details type 'show w'. This is free software, and you are welcome to redistribute it under certain conditions; type 'show c' for details."},{"path":"https://github.com/jinming-cheng/SpNeigh/articles/SpNeigh.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Getting Started with SpNeigh","text":"Recent spatial transcriptomics technologies 10x Xenium, MERFISH, Visium HD enable high-resolution profiling gene expression preserving tissue architecture. platforms opened new avenues studying tissue organization, cell–cell interactions, spatial gene regulation. existing methods focus identifying globally spatially variable genes enhancing spatial visualization, limited support modeling local spatial context, region boundaries, cell neighborhoods, gradients across tissue structures. SpNeigh R package introduces boundary-aware region-informed framework spatial neighborhood analysis spatial differential expression modeling. Key features include: Boundary detection neighborhood ring construction Spatial weighting using distances centroids boundaries Spline-based modeling gene expression along spatial gradients spatial enrichment index (SEI) quantify boundary- region-enriched genes Unlike existing Bioconductor tools spatialDE, emphasize global spatial variability, SpNeigh enables local, interpretable, geometry-aware modeling spatial expression patterns. SpNeigh supports inputs SpatialExperiment Seurat objects coordinate extraction visualization, emphasizes transparent modeling using user-supplied matrices weights—ensuring reproducibility compatibility Bioconductor workflows. integrating spatial geometry transcriptomic data, SpNeigh reveals biologically meaningful patterns intermediate cell states, microenvironmental differences, spatial gene expression gradients, critical understanding development, tissue function, disease progression.","code":""},{"path":"https://github.com/jinming-cheng/SpNeigh/articles/SpNeigh.html","id":"overview-of-this-vignette","dir":"Articles","previous_headings":"","what":"Overview of this vignette","title":"Getting Started with SpNeigh","text":"vignette demonstrates key functionalities SpNeigh package using real10x Xenium Fresh Frozen Mouse Brain Tiny Subset dataset. Specifically, show : Identify spatial boundaries construct neighboring ring regions Explore spatial interaction patterns cell clusters Perform differential expression analysis spatially defined cell populations Compute spatial weights based boundary centroid proximity Model spatial expression gradients using spline-based differential expression Quantify spatial enrichment along spatial gradients workflow highlights analytical flexibility SpNeigh illustrates neighborhood-aware modeling can reveal spatial gene expression patterns readily captured existing approaches.","code":""},{"path":"https://github.com/jinming-cheng/SpNeigh/articles/SpNeigh.html","id":"installation","dir":"Articles","previous_headings":"","what":"Installation","title":"Getting Started with SpNeigh","text":"SpNeigh package can installed GitHub using:","code":"devtools::install_github(\"jinming-cheng/SpNeigh\")"},{"path":"https://github.com/jinming-cheng/SpNeigh/articles/SpNeigh.html","id":"load-packages","dir":"Articles","previous_headings":"","what":"Load packages","title":"Getting Started with SpNeigh","text":"","code":"library(SpNeigh) library(ggplot2)"},{"path":[]},{"path":"https://github.com/jinming-cheng/SpNeigh/articles/SpNeigh.html","id":"input-coordinate-data-frame-and-normalized-expression-matrix","dir":"Articles","previous_headings":"Load data","what":"Input: Coordinate data frame and Normalized expression matrix","title":"Getting Started with SpNeigh","text":"Coordinates mouse brain dataset Ensure rownames coords cell names Log normalized expression data generated NormalizeData function Seurat package Annotate clusters based anatomical brain regions vignette, focus cluster-level rather cell type–level analyses.","code":"coords <- readRDS(system.file(\"extdata\", \"MouseBrainCoords.rds\",     package = \"SpNeigh\" )) head(coords) #>          x        y cell cluster #> 1 1898.815 2540.963    1       4 #> 2 1895.305 2532.627    2       4 #> 3 2368.073 2534.409    3       2 #> 4 1903.726 2560.010    4       4 #> 5 1917.481 2543.132    5       4 #> 6 1926.540 2560.044    6       4 rownames(coords) <- coords$cell logNorm_expr <- readRDS(system.file(\"extdata\", \"LogNormExpr.rds\",     package = \"SpNeigh\" )) class(logNorm_expr) #> [1] \"dgCMatrix\" #> attr(,\"package\") #> [1] \"Matrix\" new_cell_types <- c(     \"0\" = \"Meninges\",     \"1\" = \"Cerebral_cortex\",     \"2\" = \"White_matter\",     \"3\" = \"Cerebral_cortex\",     \"4\" = \"Cerebral_cortex\",     \"5\" = \"Thalamus\",     \"6\" = \"Cerebral_cortex\",     \"7\" = \"Hippocampus\",     \"8\" = \"Hippocampus\",     \"9\" = \"Hippocampus\",     \"10\" = \"White_matter\",     \"11\" = \"Cerebral_cortex\" )"},{"path":"https://github.com/jinming-cheng/SpNeigh/articles/SpNeigh.html","id":"alternative-input-spatialexperiment-object","dir":"Articles","previous_headings":"Load data","what":"Alternative input: SpatialExperiment object","title":"Getting Started with SpNeigh","text":"Coordinates cells clusters 0 2 metadata cells clusters 0 2 Create SpatialExperiment Extract coordinates SpatialExperiment object Extract log-normalized expression matrix SpatialExperiment object","code":"coords_sub <- subset(coords, cluster %in% c(\"0\", \"2\")) coords_sub <- as.matrix(coords_sub[, c(\"x\", \"y\")]) metadata_sub <- subset(coords[, c(\"cell\", \"cluster\")], cluster %in% c(\"0\", \"2\")) spe <- SpatialExperiment::SpatialExperiment(     assay = list(\"logcounts\" = logNorm_expr),     colData = metadata_sub,     spatialCoords = coords_sub ) spe #> class: SpatialExperiment  #> dim: 248 11617  #> metadata(0): #> assays(1): logcounts #> rownames(248): 2010300C02Rik Acsbg1 ... Zfp536 Zfpm2 #> rowData names(0): #> colnames(11617): 3 8 ... 36595 36597 #> colData names(3): cell cluster sample_id #> reducedDimNames(0): #> mainExpName: NULL #> altExpNames(0): #> spatialCoords names(2) : x y #> imgData names(0): spe_coords <- extractCoords(spe) spe_logcounts <- SingleCellExperiment::logcounts(spe)"},{"path":"https://github.com/jinming-cheng/SpNeigh/articles/SpNeigh.html","id":"alternative-input-seurat-object","dir":"Articles","previous_headings":"Load data","what":"Alternative input: Seurat object","title":"Getting Started with SpNeigh","text":"Load Seurat pacakge Create Seurat object (Note: normalized expression matrix used tutorial purposes . practice, use raw count matrix.) Insert normalized data data layer (Seurat v5) Add FOV Add seurat_clusters metadata Extract coordinates Seurat object Extract log-normalized expression matrix Seurat object","code":"library(Seurat) #> Loading required package: SeuratObject #> Loading required package: sp #> 'SeuratObject' was built with package 'Matrix' 1.7.1 but the current #> version is 1.7.4; it is recomended that you reinstall 'SeuratObject' as #> the ABI for 'Matrix' may have changed #>  #> Attaching package: 'SeuratObject' #> The following objects are masked from 'package:base': #>  #>     intersect, t seu_sp <- CreateSeuratObject(     assay = \"Spatial\",     counts = logNorm_expr,     meta.data = metadata_sub ) seu_sp #> An object of class Seurat  #> 248 features across 11617 samples within 1 assay  #> Active assay: Spatial (248 features, 0 variable features) #>  1 layer present: counts LayerData(seu_sp, assay = \"Spatial\", layer = \"data\") <- logNorm_expr cents <- CreateCentroids(coords_sub[, c(\"x\", \"y\")])  fov <- CreateFOV(     coords = list(\"centroids\" = cents),     type = c(\"centroids\"),     assay = \"Spatial\" )  seu_sp[[\"fov\"]] <- fov seu_sp$seurat_clusters <- seu_sp$cluster seu_sp_coords <- extractCoords(seu_sp) seu_sp_log_expr <- GetAssayData(seu_sp)"},{"path":[]},{"path":"https://github.com/jinming-cheng/SpNeigh/articles/SpNeigh.html","id":"quick-look-at-the-boundaries-of-one-cluster","dir":"Articles","previous_headings":"Neighborhood analysis for cluster 2 cells","what":"Quick look at the boundaries of one cluster","title":"Getting Started with SpNeigh","text":"Quick look boundaries cluster 2 using default parameter settings. input SpatialExperiment object.  Similarly, can use Seurat object input adjust parameters","code":"plotBoundary(spe, one_cluster = \"2\") plotBoundary(seu_sp, one_cluster = \"2\", eps = 120)"},{"path":"https://github.com/jinming-cheng/SpNeigh/articles/SpNeigh.html","id":"detect-spatial-boundaries","dir":"Articles","previous_headings":"Neighborhood analysis for cluster 2 cells","what":"Detect spatial boundaries","title":"Getting Started with SpNeigh","text":"Extract boundaries cluster 2. Adjust eps minPts parameters refine number subregions detected default dbscan clustering method. Note: eps parameter controls clustering tolerance boundary detection based spatial distance. default value eps = 80, suitable coordinates range hundreds thousands (e.g., 10x Xenium Visium HD data). datasets smaller coordinate ranges (e.g., 1 5), manually scaled normalized inputs, smaller value eps = 0.1 may appropriate. Add boundaries cluster 2 spatial plot  Alternatively, add boundaries cluster 2 using addBoundary() function Plot boundary regions","code":"bon_points_c2 <- getBoundary(     data = coords,     one_cluster = 2,     eps = 120,     minPts = 10 ) table(bon_points_c2$region_id) #>  #>   1   2  #> 572 132 plotBoundary(coords, boundary = bon_points_c2) # plotBoundary(coords) + addBoundary(boundary = bon_points_c2) bon_polys_c2 <- buildBoundaryPoly(bon_points_c2) plotRegion(bon_polys_c2)"},{"path":"https://github.com/jinming-cheng/SpNeigh/articles/SpNeigh.html","id":"obtain-neighborhood-ring-regions","dir":"Articles","previous_headings":"Neighborhood analysis for cluster 2 cells","what":"Obtain neighborhood ring regions","title":"Getting Started with SpNeigh","text":"Get spatial ring-shaped regions subtracting original boundary polygons corresponding outer buffered polygons. outer_boundary automatically computed supplied. Plot ring regions","code":"ring_regions <- getRingRegion(boundary = bon_points_c2) plotRegion(ring_regions)"},{"path":"https://github.com/jinming-cheng/SpNeigh/articles/SpNeigh.html","id":"statistics-of-cells-inside-rings","dir":"Articles","previous_headings":"Neighborhood analysis for cluster 2 cells","what":"Statistics of cells inside rings","title":"Getting Started with SpNeigh","text":"Get cells inside rings cluster 2. (getCellsInside() takes seconds run example, may require several minutes longer larger datasets.) Plot cells inside rings  Obtain statistics cells inside rings cluster 2 Plot proportion cells different clusters sub region using bar plot.  Plot proportion cells different clusters sub region using donut chart. plot_donut = FALSE, pie chart used.","code":"cells_ring <- getCellsInside(data = coords, boundary = ring_regions) cells_ring #> Simple feature collection with 4362 features and 3 fields #> Geometry type: POINT #> Dimension:     XY #> Bounding box:  xmin: 1482.997 ymin: 1530.545 xmax: 5441.679 ymax: 3532.463 #> CRS:           NA #> First 10 features: #>    cell cluster region_id                  geometry #> 21   21       4         1 POINT (2080.017 2559.984) #> 22   22       4         1 POINT (2088.025 2526.528) #> 23   23       2         1 POINT (2085.119 2546.843) #> 24   24       2         1 POINT (2101.906 2549.501) #> 25   25       4         1 POINT (2102.112 2540.185) #> 26   26       4         1 POINT (2089.812 2539.796) #> 27   27       4         1  POINT (2095.253 2533.08) #> 28   28       4         1  POINT (2100.02 2527.252) #> 29   29       4         1 POINT (2197.507 2524.511) #> 30   30       3         1 POINT (2209.931 2542.314) plotCellsInside(cells_ring, point_size = 0.2) stats_ring <- statsCellsInside(cells_ring) plotStatsBar(stats_ring, stat_column = \"proportion\") plotStatsPie(stats_ring, plot_donut = TRUE)"},{"path":"https://github.com/jinming-cheng/SpNeigh/articles/SpNeigh.html","id":"neighborhood-interaction-of-clusters-inside-rings","dir":"Articles","previous_headings":"Neighborhood analysis for cluster 2 cells","what":"Neighborhood interaction of clusters inside rings","title":"Getting Started with SpNeigh","text":"Compute neighborhood interaction matrix using K-nearest neighbors cells inside rings Heatmap row-scaled interaction matrix cells inside rings cluster 2. heatmap reveals clusters 2, 3, 4 spatially adjacent one another.  plot cells inside rings split clusters confirms co-occurrence clusters 2, 3, 4 ring region 1.","code":"interaction_matrix <- computeSpatialInteractionMatrix(     subset(coords, cell %in% cells_ring$cell) ) interaction_matrix #>       0  1    2    3    4    5   6 7  8    9  10 11 #> 0  4090  6 1020  892  882  706 202 6 15   95  46  0 #> 1     6  0   10   10   11    0   3 0  0    0   0  0 #> 2  1266 10 1831 1127 1882  648 392 2  0   49  72  1 #> 3   980  8  973 1409 1190  104 422 3 28  187  13  3 #> 4   859  3 1685 1185 5684    0 392 0  0    0   0  2 #> 5   768  0  501   91    0 8227  10 0  0    3   0  0 #> 6   199  1  331  442  411   12 193 0 14   99   6  2 #> 7     7  0    3    9    0    0   0 0  0    1   0  0 #> 8    20  0    5   43    0    0  20 0 29   13   0  0 #> 9   108  0   39  158    0    1  79 0 11 1064   0  0 #> 10   43  0   64   12    1    0   5 0  0    0 155  0 #> 11    0  0    1    3    4    0   2 0  0    0   0  0 plotInteractionMatrix(interaction_matrix) plotCellsInside(cells_ring) +     facet_wrap(~cluster) +     Seurat::RotatedAxis() +     addBoundaryPoly(ring_regions, linewidth_boundary = 0.1)"},{"path":"https://github.com/jinming-cheng/SpNeigh/articles/SpNeigh.html","id":"de-analysis-of-cluster-2-cells-inside-and-outside-boundaries","dir":"Articles","previous_headings":"","what":"DE analysis of cluster 2 cells inside and outside boundaries","title":"Getting Started with SpNeigh","text":"cells cluster 2 located sub region 1. Hence, focus DE analysis cluster 2 cells inside boundary sub region 1 cells outside neighboring ring region 1. Get cells inside boundaries cluster 2 Obtain cluster 2 cells inside outside boundary sub region Perform DE analysis cells inside boundary outside boundary using limma framewrok (lmFit + eBayes) Top DE genes cells outside boundary cells inside boundary. DE genes ordered abstract value logFC default. Set random seed make plotExpression results reproducible Expression top DE genes cluster 2 cells outside boundary. cells plotted randomly using given seed shuffle = TRUE. shuffle = FALSE, cells higher expression values plotted last (top).  Expression Slc17a7 cluster 2 cells inside outside boundary sub region 1. Cluster 2 cells outside boundary show much higher expression Slc17a7.  Expression general marker gene Sox10 Oligodendrocytes (cluster 2 cells). Sox10 expressed cluster 2 cells inside outside boundary. suggests cluster 2 cells located near boundary may represent intermediate cell states.","code":"cells_inside <- getCellsInside(data = coords, boundary = bon_points_c2) cells_inside #> Simple feature collection with 5073 features and 3 fields #> Geometry type: POINT #> Dimension:     XY #> Bounding box:  xmin: 1590.613 ymin: 1640.136 xmax: 5443.607 ymax: 3531.379 #> CRS:           NA #> First 10 features: #>    cell cluster region_id                  geometry #> 3     3       2         1 POINT (2368.073 2534.409) #> 20   20       2         1 POINT (2456.959 2560.494) #> 31   31       2         1 POINT (2152.998 2554.538) #> 43   43       2         1 POINT (2312.183 2555.867) #> 44   44       2         1  POINT (2323.21 2551.805) #> 50   50       2         1 POINT (2356.391 2544.839) #> 52   52       2         1 POINT (2387.844 2537.827) #> 53   53       2         1 POINT (2401.216 2526.458) #> 54   54       2         1 POINT (2392.535 2555.696) #> 55   55       2         1 POINT (2407.538 2545.443) cells_in <- subset(cells_inside, region_id == 1 & cluster == 2)[[\"cell\"]] cells_out <- subset(cells_ring, region_id == 1 & cluster == 2)[[\"cell\"]] tab <- runLimmaDE(     exp_mat = logNorm_expr,     min.pct = 0.25,     cells_reference = cells_in,     cells_target = cells_out ) head(tab[, c(\"gene\", \"logFC\", \"adj.P.Val\", \"pct.reference\", \"pct.target\")]) #>            gene    logFC     adj.P.Val pct.reference pct.target #> Slc17a7 Slc17a7 2.719412 1.624032e-145     0.3228372  0.7555911 #> Cabp7     Cabp7 2.256859 1.316819e-126     0.2325064  0.6453674 #> Arc         Arc 1.932350  7.188753e-73     0.4567430  0.7779553 #> Neurod6 Neurod6 1.788980 5.267216e-123     0.1224555  0.5063898 #> Igfbp4   Igfbp4 1.608183  8.429609e-96     0.1437659  0.4952077 #> Nrn1       Nrn1 1.590518  4.942213e-65     0.2722646  0.5926518 set.seed(123) plotExpression(     data = coords[colnames(logNorm_expr), ],     exp_mat = logNorm_expr,     genes = tab$gene[1:2],     sub_plot = TRUE,     one_cluster = 2,     shuffle = TRUE,     point_size = 0.1,     angle_x_label = 45 ) plotExpression(     data = coords[colnames(logNorm_expr), ],     exp_mat = logNorm_expr,     genes = \"Slc17a7\",     sub_plot = TRUE,     shuffle = TRUE,     sub_cells = c(cells_in, cells_out),     point_size = 0.3 ) +     addBoundaryPoly(bon_polys_c2[1, ], linewidth_boundary = 0.5) plotExpression(     data = coords[colnames(logNorm_expr), ],     exp_mat = logNorm_expr,     sub_cells = c(cells_in, cells_out),     sub_plot = TRUE,     genes = \"Sox10\",     shuffle = TRUE,     point_size = 0.3 ) +     addBoundaryPoly(bon_polys_c2[1, ], linewidth_boundary = 0.5)"},{"path":[]},{"path":"https://github.com/jinming-cheng/SpNeigh/articles/SpNeigh.html","id":"detect-spatial-boundaries-1","dir":"Articles","previous_headings":"Spatial DE analysis of cells in cluster 0 along spatial weights","what":"Detect spatial boundaries","title":"Getting Started with SpNeigh","text":"Obtain cells cluster 0 Plot cluster 0 cells without boundary  Get boundaries cluster 0 Plot boundary edges cluster 0","code":"cells_c0 <- subset(coords, cluster == 0)[, \"cell\"] plotBoundary(coords[cells_c0, ]) bon_points_c0 <- getBoundary(data = coords, one_cluster = 0) bon_polys_c0 <- buildBoundaryPoly(bon_points_c0) plotEdge(boundary_poly = bon_polys_c0, linewidth_boundary = 0.6)"},{"path":"https://github.com/jinming-cheng/SpNeigh/articles/SpNeigh.html","id":"compute-and-plot-spatial-weights","dir":"Articles","previous_headings":"Spatial DE analysis of cells in cluster 0 along spatial weights","what":"Compute and plot spatial weights","title":"Getting Started with SpNeigh","text":"Compute spatial weights based distance boundaries Spatial weights named vector, names correspond cell IDs Alternatively, compute spatial weights based distance centroids Plot boundary weights","code":"weights_bon <- computeBoundaryWeights(     data = coords,     cell_ids = cells_c0,     boundary = bon_points_c0 ) weights_bon[1:3] #>        39        42        75  #> 0.7016421 0.6955660 0.6805249 weights_cen <- computeCentroidWeights(data = coords, cell_ids = cells_c0) plotWeights(data = coords, weights = weights_bon, point_size = 0.8) +     labs(title = \"Boundary weights\")"},{"path":"https://github.com/jinming-cheng/SpNeigh/articles/SpNeigh.html","id":"perform-spatial-differential-analysis-along-boundary-weights","dir":"Articles","previous_headings":"Spatial DE analysis of cells in cluster 0 along spatial weights","what":"Perform spatial differential analysis along boundary weights","title":"Getting Started with SpNeigh","text":"Run spatial DE analysis cluster 0 cells along boundary weights using splines Top DE genes along boundary weights. first spline coefficient (Z1) captures main expression trend along spatial distance. positive value indicates increasing expression distance, negative value indicates decreasing expression. Expression top DE genes along boundary weights  Plot scaled average expression along boundary weight bins top 10 spatial DE genes. scaled average expression ranges 0 1 using min-max normalization method.","code":"tab_sp <- runSpatialDE(     exp_mat = logNorm_expr[, cells_c0],     spatial_distance = weights_bon,     cell_ids = cells_c0 ) head(tab_sp) #>                Z1        Z2        Z3  AveExpr         F P.Value adj.P.Val #> Aldh1a2  90.19564 -72.83701  18.56803 1.642933 1156.7476       0         0 #> Car4    -86.85851  37.72830 -30.91311 3.007433  590.8437       0         0 #> Col1a1   84.54759 -60.30661  21.47013 1.675953  885.1705       0         0 #> Dcn     112.15109 -72.28618  28.47200 2.337544 1295.7527       0         0 #> Fmod     91.46180 -63.54536  20.99449 1.562370 1083.7186       0         0 #> Gjb2     67.07620 -52.43818  14.55533 1.193263  742.6493       0         0 #>            gene    trend #> Aldh1a2 Aldh1a2 Positive #> Car4       Car4 Negative #> Col1a1   Col1a1 Positive #> Dcn         Dcn Positive #> Fmod       Fmod Positive #> Gjb2       Gjb2 Positive plotExpression(     data = coords[colnames(logNorm_expr), ],     exp_mat = logNorm_expr,     genes = tab_sp$gene[1:2],     sub_plot = TRUE,     one_cluster = 0,     shuffle = TRUE,     point_size = 0.1,     angle_x_label = 45 ) plotSpatialExpression(     exp_mat = logNorm_expr[, cells_c0],     spatial_distance = weights_bon,     scale_method = \"minmax\",     genes = tab_sp$gene[1:10],     label_x = \"Boundary weights\" )"},{"path":"https://github.com/jinming-cheng/SpNeigh/articles/SpNeigh.html","id":"spatial-enrichment-analysis-for-each-gene","dir":"Articles","previous_headings":"","what":"Spatial enrichment analysis for each gene","title":"Getting Started with SpNeigh","text":"Compute spatial enrichment index (SEI) gene based boundary weights. SEI reflects extent gene expression enriched spatially weighted regions. result sorted descending order normalized_SEI. Expression top genes enriched near boundaries","code":"SEI_bon <- computeSpatialEnrichmentIndex(     exp_mat = logNorm_expr[, cells_c0],     weights = weights_bon ) head(SEI_bon) #>      gene      SEI mean_expr normalized_SEI #> 1    Fmod 1.742086  1.562370       1.115027 #> 2    Gjb2 1.325063  1.193263       1.110452 #> 3 Aldh1a2 1.820161  1.642933       1.107872 #> 4 Slc13a4 2.106610  1.906511       1.104955 #> 5  Col1a1 1.842083  1.675953       1.099125 #> 6  Cyp1b1 1.495145  1.365958       1.094575 plotExpression(     data = coords[colnames(logNorm_expr), ],     exp_mat = logNorm_expr,     genes = SEI_bon$gene[1:2],     sub_plot = TRUE,     one_cluster = 0,     shuffle = TRUE,     point_size = 0.1,     angle_x_label = 45 )"},{"path":"https://github.com/jinming-cheng/SpNeigh/articles/SpNeigh.html","id":"session-info","dir":"Articles","previous_headings":"","what":"Session Info","title":"Getting Started with SpNeigh","text":"","code":"sessionInfo() #> R version 4.4.2 (2024-10-31) #> Platform: x86_64-pc-linux-gnu #> Running under: Ubuntu 24.04.1 LTS #>  #> Matrix products: default #> BLAS:   /usr/lib/x86_64-linux-gnu/openblas-pthread/libblas.so.3  #> LAPACK: /usr/lib/x86_64-linux-gnu/openblas-pthread/libopenblasp-r0.3.26.so;  LAPACK version 3.12.0 #>  #> locale: #>  [1] LC_CTYPE=en_US.UTF-8       LC_NUMERIC=C               #>  [3] LC_TIME=en_US.UTF-8        LC_COLLATE=en_US.UTF-8     #>  [5] LC_MONETARY=en_US.UTF-8    LC_MESSAGES=en_US.UTF-8    #>  [7] LC_PAPER=en_US.UTF-8       LC_NAME=C                  #>  [9] LC_ADDRESS=C               LC_TELEPHONE=C             #> [11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C        #>  #> time zone: UTC #> tzcode source: system (glibc) #>  #> attached base packages: #> [1] stats     graphics  grDevices utils     datasets  methods   base      #>  #> other attached packages: #> [1] Seurat_5.4.0       SeuratObject_5.3.0 sp_2.2-0           ggplot2_4.0.2      #> [5] SpNeigh_0.99.32    BiocStyle_2.34.0   #>  #> loaded via a namespace (and not attached): #>   [1] RcppAnnoy_0.0.23            splines_4.4.2               #>   [3] later_1.4.5                 tibble_3.3.1                #>   [5] polyclip_1.10-7             fastDummies_1.7.5           #>   [7] lifecycle_1.0.5             sf_1.0-24                   #>   [9] globals_0.19.0              lattice_0.22-9              #>  [11] MASS_7.3-65                 magrittr_2.0.4              #>  [13] limma_3.62.2                plotly_4.12.0               #>  [15] sass_0.4.10                 rmarkdown_2.30              #>  [17] jquerylib_0.1.4             yaml_2.3.12                 #>  [19] httpuv_1.6.16               otel_0.2.0                  #>  [21] sctransform_0.4.3           spam_2.11-3                 #>  [23] spatstat.sparse_3.1-0       reticulate_1.44.1           #>  [25] cowplot_1.2.0               pbapply_1.7-4               #>  [27] DBI_1.2.3                   RColorBrewer_1.1-3          #>  [29] abind_1.4-8                 zlibbioc_1.52.0             #>  [31] Rtsne_0.17                  GenomicRanges_1.58.0        #>  [33] purrr_1.2.1                 BiocGenerics_0.52.0         #>  [35] GenomeInfoDbData_1.2.13     IRanges_2.40.1              #>  [37] S4Vectors_0.44.0            ggrepel_0.9.6               #>  [39] irlba_2.3.7                 listenv_0.10.0              #>  [41] spatstat.utils_3.2-1        units_1.0-0                 #>  [43] goftest_1.2-3               RSpectra_0.16-2             #>  [45] spatstat.random_3.4-4       fitdistrplus_1.2-6          #>  [47] parallelly_1.46.1           pkgdown_2.2.0               #>  [49] codetools_0.2-20            DelayedArray_0.32.0         #>  [51] tidyselect_1.2.1            UCSC.utils_1.2.0            #>  [53] farver_2.1.2                matrixStats_1.5.0           #>  [55] stats4_4.4.2                spatstat.explore_3.7-0      #>  [57] jsonlite_2.0.0              e1071_1.7-17                #>  [59] progressr_0.18.0            ggridges_0.5.7              #>  [61] survival_3.8-6              systemfonts_1.3.1           #>  [63] dbscan_1.2.4                tools_4.4.2                 #>  [65] ragg_1.5.0                  ica_1.0-3                   #>  [67] Rcpp_1.1.1                  glue_1.8.0                  #>  [69] gridExtra_2.3               SparseArray_1.6.2           #>  [71] xfun_0.56                   MatrixGenerics_1.18.1       #>  [73] GenomeInfoDb_1.42.3         dplyr_1.2.0                 #>  [75] withr_3.0.2                 BiocManager_1.30.27         #>  [77] fastmap_1.2.0               digest_0.6.39               #>  [79] R6_2.6.1                    mime_0.13                   #>  [81] textshaping_1.0.4           scattermore_1.2             #>  [83] tensor_1.5.1                spatstat.data_3.1-9         #>  [85] tidyr_1.3.2                 generics_0.1.4              #>  [87] data.table_1.18.2.1         FNN_1.1.4.1                 #>  [89] class_7.3-23                httr_1.4.7                  #>  [91] htmlwidgets_1.6.4           S4Arrays_1.6.0              #>  [93] uwot_0.2.4                  pkgconfig_2.0.3             #>  [95] gtable_0.3.6                lmtest_0.9-40               #>  [97] S7_0.2.1                    SingleCellExperiment_1.28.1 #>  [99] XVector_0.46.0              htmltools_0.5.9             #> [101] dotCall64_1.2               bookdown_0.46               #> [103] scales_1.4.0                Biobase_2.66.0              #> [105] png_0.1-8                   SpatialExperiment_1.16.0    #> [107] spatstat.univar_3.1-6       knitr_1.51                  #> [109] reshape2_1.4.5              rjson_0.2.23                #> [111] nlme_3.1-168                curl_7.0.0                  #> [113] proxy_0.4-29                cachem_1.1.0                #> [115] zoo_1.8-15                  stringr_1.6.0               #> [117] KernSmooth_2.23-26          parallel_4.4.2              #> [119] miniUI_0.1.2                concaveman_1.2.0            #> [121] desc_1.4.3                  pillar_1.11.1               #> [123] grid_4.4.2                  vctrs_0.7.1                 #> [125] RANN_2.6.2                  promises_1.5.0              #> [127] xtable_1.8-4                cluster_2.1.8.2             #> [129] evaluate_1.0.5              magick_2.9.0                #> [131] cli_3.6.5                   compiler_4.4.2              #> [133] rlang_1.1.7                 crayon_1.5.3                #> [135] future.apply_1.20.1         labeling_0.4.3              #> [137] classInt_0.4-11             plyr_1.8.9                  #> [139] fs_1.6.6                    stringi_1.8.7               #> [141] viridisLite_0.4.3           deldir_2.0-4                #> [143] lazyeval_0.2.2              spatstat.geom_3.7-0         #> [145] V8_8.0.1                    Matrix_1.7-4                #> [147] RcppHNSW_0.6.0              patchwork_1.3.2             #> [149] future_1.69.0               statmod_1.5.1               #> [151] shiny_1.12.1                SummarizedExperiment_1.36.0 #> [153] ROCR_1.0-12                 igraph_2.2.1                #> [155] bslib_0.10.0"},{"path":"https://github.com/jinming-cheng/SpNeigh/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Jinming Cheng. Author, maintainer.","code":""},{"path":"https://github.com/jinming-cheng/SpNeigh/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Cheng J, Chow P, Liu N (2025). “SpNeigh: spatial neighborhood differential expression analysis high-resolution spatial transcriptomics.” bioRxiv. doi:10.1101/2025.11.07.687304.","code":"@Article{,   title = {SpNeigh: spatial neighborhood and differential expression analysis for high-resolution spatial transcriptomics},   author = {Jinming Cheng and Pierce Kah Hoe Chow and Nan Liu},   journal = {bioRxiv},   year = {2025},   doi = {10.1101/2025.11.07.687304}, }"},{"path":"https://github.com/jinming-cheng/SpNeigh/index.html","id":"spneigh-","dir":"","previous_headings":"","what":"Spatial Neighborhood Modeling and Differential Expression Analysis for Transcriptomics","title":"Spatial Neighborhood Modeling and Differential Expression Analysis for Transcriptomics","text":"SpNeigh provides methods neighborhood-aware analysis spatial transcriptomics data. supports boundary detection, spatial weighting (centroid- boundary-based), spatially informed differential expression using spline-based models, spatial enrichment analysis via Spatial Enrichment Index (SEI). Designed compatibility Seurat objects, SpatialExperiment objects spatial data frames, SpNeigh enables interpretable, publication-ready analysis spatial gene expression patterns. Quick start guide can found .","code":""},{"path":"https://github.com/jinming-cheng/SpNeigh/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Spatial Neighborhood Modeling and Differential Expression Analysis for Transcriptomics","text":"SpNeigh package can installed GitHub using:","code":"devtools::install_github(\"jinming-cheng/SpNeigh\")"},{"path":"https://github.com/jinming-cheng/SpNeigh/index.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Spatial Neighborhood Modeling and Differential Expression Analysis for Transcriptomics","text":"Please cite article use SpNeigh:","code":"To cite SpNeigh in publications, please use:    Cheng J, Chow P, Liu N (2025). \"SpNeigh: spatial neighborhood and   differential expression analysis for high-resolution spatial   transcriptomics.\" _bioRxiv_. doi:10.1101/2025.11.07.687304   <https://doi.org/10.1101/2025.11.07.687304>.  A BibTeX entry for LaTeX users is    @Article{,     title = {SpNeigh: spatial neighborhood and differential expression analysis for high-resolution spatial transcriptomics},     author = {Jinming Cheng and Pierce Kah Hoe Chow and Nan Liu},     journal = {bioRxiv},     year = {2025},     doi = {10.1101/2025.11.07.687304},   }"},{"path":"https://github.com/jinming-cheng/SpNeigh/reference/AddBoundary.html","id":null,"dir":"Reference","previous_headings":"","what":"Add boundary outlines to a spatial ggplot — addBoundary","title":"Add boundary outlines to a spatial ggplot — addBoundary","text":"Overlays spatial boundaries (points polygons) onto ggplot2 object. input can either data frame boundary points sf object POLYGON geometries. function typically used additive layer (+ addBoundary(...)) conjunction base plot created using plotBoundary().","code":""},{"path":"https://github.com/jinming-cheng/SpNeigh/reference/AddBoundary.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Add boundary outlines to a spatial ggplot — addBoundary","text":"","code":"addBoundary(   boundary = NULL,   color_boundary = \"black\",   linewidth_boundary = 1.5 )"},{"path":"https://github.com/jinming-cheng/SpNeigh/reference/AddBoundary.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Add boundary outlines to a spatial ggplot — addBoundary","text":"boundary data frame columns x, y, region_id sf object POLYGON LINESTRING geometries. color_boundary Color boundary lines. Default \"black\". linewidth_boundary Numeric. Line width boundary outlines. Default 1.5.","code":""},{"path":"https://github.com/jinming-cheng/SpNeigh/reference/AddBoundary.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Add boundary outlines to a spatial ggplot — addBoundary","text":"ggplot2::geom_path layer can added existing plot.","code":""},{"path":"https://github.com/jinming-cheng/SpNeigh/reference/AddBoundary.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Add boundary outlines to a spatial ggplot — addBoundary","text":"","code":"coords <- readRDS(system.file(\"extdata\", \"MouseBrainCoords.rds\",     package = \"SpNeigh\" ))  # Automatically get boundary for a cluster boundary_points <- getBoundary(     data = coords, one_cluster = 2,     subregion_method = \"dbscan\",     eps = 120, minPts = 10 )  # Plot with boundary overlay plotBoundary(coords) + addBoundary(boundary_points)"},{"path":"https://github.com/jinming-cheng/SpNeigh/reference/AddBoundaryPoly.html","id":null,"dir":"Reference","previous_headings":"","what":"Add boundary polygons or linestrings to a spatial plot — addBoundaryPoly","title":"Add boundary polygons or linestrings to a spatial plot — addBoundaryPoly","text":"Overlays boundary polygons linestrings spatial ggplot2 plot. function adds sf geometry layer display complete boundary shapes visualizing spatial clusters, rings, enriched zones.","code":""},{"path":"https://github.com/jinming-cheng/SpNeigh/reference/AddBoundaryPoly.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Add boundary polygons or linestrings to a spatial plot — addBoundaryPoly","text":"","code":"addBoundaryPoly(   boundary_poly,   color_boundary = \"black\",   linewidth_boundary = 1.5 )"},{"path":"https://github.com/jinming-cheng/SpNeigh/reference/AddBoundaryPoly.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Add boundary polygons or linestrings to a spatial plot — addBoundaryPoly","text":"boundary_poly sf object containing POLYGON LINESTRING geometries region_id column. color_boundary Color boundary lines. Default \"black\". linewidth_boundary Numeric. Line width boundary outlines. Default 1.5.","code":""},{"path":"https://github.com/jinming-cheng/SpNeigh/reference/AddBoundaryPoly.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Add boundary polygons or linestrings to a spatial plot — addBoundaryPoly","text":"ggplot2::geom_sf layer can added existing plot.","code":""},{"path":"https://github.com/jinming-cheng/SpNeigh/reference/AddBoundaryPoly.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Add boundary polygons or linestrings to a spatial plot — addBoundaryPoly","text":"","code":"coords <- readRDS(system.file(\"extdata\", \"MouseBrainCoords.rds\",     package = \"SpNeigh\" ))  boundary_points <- getBoundary(     data = coords, one_cluster = 2,     subregion_method = \"dbscan\",     eps = 120, minPts = 10 ) boundary_polys <- buildBoundaryPoly(boundary_points)  # Add boundary polygons to the plot plotBoundary(coords) +     addBoundaryPoly(boundary_polys, color_boundary = \"blue\")"},{"path":"https://github.com/jinming-cheng/SpNeigh/reference/BoundaryPolyToPoints.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert boundary polygons to boundary point coordinates — boundaryPolyToPoints","title":"Convert boundary polygons to boundary point coordinates — boundaryPolyToPoints","text":"Extracts vertex coordinates (x, y) boundary geometries sf object containing POLYGON LINESTRING features. useful recovering original boundary points smoothed labeled polygonal regions.","code":""},{"path":"https://github.com/jinming-cheng/SpNeigh/reference/BoundaryPolyToPoints.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert boundary polygons to boundary point coordinates — boundaryPolyToPoints","text":"","code":"boundaryPolyToPoints(boundary_poly = NULL)"},{"path":"https://github.com/jinming-cheng/SpNeigh/reference/BoundaryPolyToPoints.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert boundary polygons to boundary point coordinates — boundaryPolyToPoints","text":"boundary_poly sf object containing POLYGON LINESTRING geometries. Must include region_id column labeling subregions.","code":""},{"path":"https://github.com/jinming-cheng/SpNeigh/reference/BoundaryPolyToPoints.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert boundary polygons to boundary point coordinates — boundaryPolyToPoints","text":"data frame columns x, y, region_id, containing vertex coordinates boundary geometries.","code":""},{"path":"https://github.com/jinming-cheng/SpNeigh/reference/BoundaryPolyToPoints.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Convert boundary polygons to boundary point coordinates — boundaryPolyToPoints","text":"","code":"# Load coordinates and generate boundary coords <- readRDS(system.file(\"extdata\", \"MouseBrainCoords.rds\",     package = \"SpNeigh\" )) boundary_points <- getBoundary(data = coords, one_cluster = 2) boundary_polys <- buildBoundaryPoly(boundary_points)  # Convert back to boundary points boundary_pts <- boundaryPolyToPoints(boundary_polys) #> Warning: repeating attributes for all sub-geometries for which they may not be constant head(boundary_pts) #>            x        y region_id #> 1   1698.220 3196.813         1 #> 1.1 1718.113 3201.256         1 #> 1.2 1718.264 3211.133         1 #> 1.3 1732.328 3227.695         1 #> 1.4 1707.091 3262.311         1 #> 1.5 1698.292 3289.946         1"},{"path":"https://github.com/jinming-cheng/SpNeigh/reference/BuildBoundaryPoly.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert boundary points into valid polygon geometries — buildBoundaryPoly","title":"Convert boundary points into valid polygon geometries — buildBoundaryPoly","text":"Constructs spatial polygon objects boundary points generated getBoundary() function. set boundary points (grouped region_id) converted closed polygon. function ensures polygon valid ready downstream spatial analysis.","code":""},{"path":"https://github.com/jinming-cheng/SpNeigh/reference/BuildBoundaryPoly.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert boundary points into valid polygon geometries — buildBoundaryPoly","text":"","code":"buildBoundaryPoly(boundary = NULL)"},{"path":"https://github.com/jinming-cheng/SpNeigh/reference/BuildBoundaryPoly.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert boundary points into valid polygon geometries — buildBoundaryPoly","text":"boundary data frame boundary points, typically returned getBoundary(). Must contain columns x, y, region_id.","code":""},{"path":"https://github.com/jinming-cheng/SpNeigh/reference/BuildBoundaryPoly.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert boundary points into valid polygon geometries — buildBoundaryPoly","text":"sf object containing one valid POLYGON geometries region_id column.","code":""},{"path":"https://github.com/jinming-cheng/SpNeigh/reference/BuildBoundaryPoly.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Convert boundary points into valid polygon geometries — buildBoundaryPoly","text":"","code":"# Load coordinates coords <- readRDS(system.file(\"extdata\", \"MouseBrainCoords.rds\",     package = \"SpNeigh\" ))  # Get boundary points for cluster 2 boundary_points <- getBoundary(data = coords, one_cluster = 2)  # Convert to polygon boundary_polys <- buildBoundaryPoly(boundary_points)  # Plot the resulting polygons plot(boundary_polys)"},{"path":"https://github.com/jinming-cheng/SpNeigh/reference/ComputeBoundaryWeights.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute spatial weights based on distance to nearest boundary — computeBoundaryWeights","title":"Compute spatial weights based on distance to nearest boundary — computeBoundaryWeights","text":"Computes spatial weights subset cells based Euclidean distance nearest boundary segment. method supports closed boundary polygons open boundary edges (e.g., LINESTRINGs), useful modeling proximity-based enrichment near anatomical user-defined regions.","code":""},{"path":"https://github.com/jinming-cheng/SpNeigh/reference/ComputeBoundaryWeights.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute spatial weights based on distance to nearest boundary — computeBoundaryWeights","text":"","code":"computeBoundaryWeights(   data = NULL,   cell_ids = NULL,   boundary = NULL,   scale = TRUE,   method = c(\"inverse\", \"gaussian\", \"linear\", \"quadratic\"),   sigma = 0.5 )"},{"path":"https://github.com/jinming-cheng/SpNeigh/reference/ComputeBoundaryWeights.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute spatial weights based on distance to nearest boundary — computeBoundaryWeights","text":"data data frame, Seurat object SpatialExperiment object containing spatial coordinates. Must include columns: cell, x, y. cell_ids character vector cell IDs use weight computation. boundary Either sf object containing boundary geometries (POLYGON LINESTRING), data frame boundary points returned getBoundary(). scale Logical. Whether scale distances range [0, 1] applying decay functions. Default TRUE. method Decay function convert distances weights. One : \"inverse\", \"gaussian\", \"linear\", \"quadratic\". sigma Standard deviation Gaussian decay (used method = \"gaussian\"). Default 0.5 (recommended scaled distances).","code":""},{"path":"https://github.com/jinming-cheng/SpNeigh/reference/ComputeBoundaryWeights.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute spatial weights based on distance to nearest boundary — computeBoundaryWeights","text":"named numeric vector weights, names corresponding cell_ids.","code":""},{"path":"https://github.com/jinming-cheng/SpNeigh/reference/ComputeBoundaryWeights.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Compute spatial weights based on distance to nearest boundary — computeBoundaryWeights","text":"Supports multiple decay methods converting distance weights. Optionally scales distances [0, 1] range computing weights.","code":""},{"path":"https://github.com/jinming-cheng/SpNeigh/reference/ComputeBoundaryWeights.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compute spatial weights based on distance to nearest boundary — computeBoundaryWeights","text":"","code":"# Load spatial coordinates coords <- readRDS(system.file(\"extdata\", \"MouseBrainCoords.rds\",     package = \"SpNeigh\" ))  # Get and build boundary polygons from cluster 2 boundary_points <- getBoundary(data = coords, one_cluster = 2) boundary_polys <- buildBoundaryPoly(boundary_points)  # Compute weights to polygon boundary cells_c2 <- subset(coords, cluster == 2)$cell weights <- computeBoundaryWeights(     data = coords, cell_ids = cells_c2,     boundary = boundary_polys[1, ] )  # Compute weights to a specific boundary edge boundary_edges <- splitBoundaryPolyByAnchor(boundary_polys[1, ]) weights_edge <- computeBoundaryWeights(     data = coords, cell_ids = cells_c2,     boundary = boundary_edges[2, ] )"},{"path":"https://github.com/jinming-cheng/SpNeigh/reference/ComputeCentroidWeights.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute spatial weights based on distance to the centroid — computeCentroidWeights","title":"Compute spatial weights based on distance to the centroid — computeCentroidWeights","text":"Computes spatial weights set cells based Euclidean distance centroid selected group cells. useful modeling gradient-like spatial expression centered around cluster region. Supports multiple decay methods optional distance scaling.","code":""},{"path":"https://github.com/jinming-cheng/SpNeigh/reference/ComputeCentroidWeights.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute spatial weights based on distance to the centroid — computeCentroidWeights","text":"","code":"computeCentroidWeights(   data = NULL,   cell_ids = NULL,   scale = TRUE,   method = c(\"inverse\", \"gaussian\", \"linear\", \"quadratic\"),   sigma = 0.5 )"},{"path":"https://github.com/jinming-cheng/SpNeigh/reference/ComputeCentroidWeights.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute spatial weights based on distance to the centroid — computeCentroidWeights","text":"data data frame, Seurat object SpatialExperiment object containing spatial coordinates. Must include columns: cell, x, y. cell_ids character vector cell IDs use weight computation. scale Logical. Whether scale distances range [0, 1] applying decay functions. Default TRUE. method Decay function convert distances weights. One : \"inverse\", \"gaussian\", \"linear\", \"quadratic\". sigma Standard deviation Gaussian decay (used method = \"gaussian\"). Default 0.5 (recommended scaled distances).","code":""},{"path":"https://github.com/jinming-cheng/SpNeigh/reference/ComputeCentroidWeights.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute spatial weights based on distance to the centroid — computeCentroidWeights","text":"named numeric vector weights (length = number cells cell_ids). Higher weights correspond cells closer centroid.","code":""},{"path":"https://github.com/jinming-cheng/SpNeigh/reference/ComputeCentroidWeights.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compute spatial weights based on distance to the centroid — computeCentroidWeights","text":"","code":"# Load spatial coordinates coords <- readRDS(system.file(\"extdata\", \"MouseBrainCoords.rds\",     package = \"SpNeigh\" ))  # Select cells from cluster 2 cells_c2 <- subset(coords, cluster == 2)$cell  # Compute centroid-based weights using default settings weights <- computeCentroidWeights(data = coords, cell_ids = cells_c2) head(weights) #>         3         8         9        11        18        20  #> 0.7829382 0.7033367 0.7067281 0.7090737 0.7185800 0.8012193"},{"path":"https://github.com/jinming-cheng/SpNeigh/reference/ComputeSEI.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute Spatial Enrichment Index (SEI) — computeSEI","title":"Compute Spatial Enrichment Index (SEI) — computeSEI","text":"Alias computeSpatialEnrichmentIndex.","code":""},{"path":"https://github.com/jinming-cheng/SpNeigh/reference/ComputeSEI.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute Spatial Enrichment Index (SEI) — computeSEI","text":"","code":"computeSEI(exp_mat = NULL, weights = NULL)"},{"path":"https://github.com/jinming-cheng/SpNeigh/reference/ComputeSEI.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute Spatial Enrichment Index (SEI) — computeSEI","text":"exp_mat normalized gene expression matrix genes rows cells columns. class matrix dgCMatrix. weights numeric vector spatial weights (e.g., computeBoundaryWeights computeCentroidWeights). Must length number columns (cells) exp_mat.","code":""},{"path":"https://github.com/jinming-cheng/SpNeigh/reference/ComputeSEI.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute Spatial Enrichment Index (SEI) — computeSEI","text":"data frame containing spatial enrichment index (SEI) results.","code":""},{"path":"https://github.com/jinming-cheng/SpNeigh/reference/ComputeSEI.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compute Spatial Enrichment Index (SEI) — computeSEI","text":"","code":"# Load spatial coordinates and log-normalized expression coords <- readRDS(system.file(\"extdata\", \"MouseBrainCoords.rds\",     package = \"SpNeigh\" )) logNorm_expr <- readRDS(system.file(\"extdata\", \"LogNormExpr.rds\",     package = \"SpNeigh\" ))  # Compute spatial weights and SEI bon_c0 <- getBoundary(data = coords, one_cluster = 0) cells_c0 <- subset(coords, cluster == 0)$cell weights <- computeBoundaryWeights(     data = coords,     cell_ids = cells_c0,     boundary = bon_c0 ) sei_df <- computeSEI(logNorm_expr[, cells_c0], weights) head(sei_df) #>      gene      SEI mean_expr normalized_SEI #> 1    Fmod 1.742086  1.562370       1.115027 #> 2    Gjb2 1.325063  1.193263       1.110452 #> 3 Aldh1a2 1.820161  1.642933       1.107872 #> 4 Slc13a4 2.106610  1.906511       1.104955 #> 5  Col1a1 1.842083  1.675953       1.099125 #> 6  Cyp1b1 1.495145  1.365958       1.094575"},{"path":"https://github.com/jinming-cheng/SpNeigh/reference/ComputeSpatialEnrichmentIndex.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute Spatial Enrichment Index (SEI) for Each Gene — computeSpatialEnrichmentIndex","title":"Compute Spatial Enrichment Index (SEI) for Each Gene — computeSpatialEnrichmentIndex","text":"Calculates spatial enrichment index (SEI) gene based user-supplied set spatial weights. SEI reflects extent gene expression enriched spatially weighted regions tissue (e.g., near boundaries centroids).","code":""},{"path":"https://github.com/jinming-cheng/SpNeigh/reference/ComputeSpatialEnrichmentIndex.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute Spatial Enrichment Index (SEI) for Each Gene — computeSpatialEnrichmentIndex","text":"","code":"computeSpatialEnrichmentIndex(exp_mat = NULL, weights = NULL)"},{"path":"https://github.com/jinming-cheng/SpNeigh/reference/ComputeSpatialEnrichmentIndex.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute Spatial Enrichment Index (SEI) for Each Gene — computeSpatialEnrichmentIndex","text":"exp_mat normalized gene expression matrix genes rows cells columns. class matrix dgCMatrix. weights numeric vector spatial weights (e.g., computeBoundaryWeights computeCentroidWeights). Must length number columns (cells) exp_mat.","code":""},{"path":"https://github.com/jinming-cheng/SpNeigh/reference/ComputeSpatialEnrichmentIndex.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute Spatial Enrichment Index (SEI) for Each Gene — computeSpatialEnrichmentIndex","text":"data frame following columns: gene Gene name SEI Spatial enrichment index: weighted mean expression across cells mean_expr Mean expression across cells (unweighted) normalized_SEI Ratio SEI mean expression; used compare genes independent baseline expression result sorted descending order normalized_SEI.","code":""},{"path":"https://github.com/jinming-cheng/SpNeigh/reference/ComputeSpatialEnrichmentIndex.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Compute Spatial Enrichment Index (SEI) for Each Gene — computeSpatialEnrichmentIndex","text":"method supports dense (matrix) sparse (dgCMatrix) gene expression formats, can applied using distance-based weighting scheme.","code":""},{"path":"https://github.com/jinming-cheng/SpNeigh/reference/ComputeSpatialEnrichmentIndex.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compute Spatial Enrichment Index (SEI) for Each Gene — computeSpatialEnrichmentIndex","text":"","code":"# Load spatial coordinates and log-normalized expression coords <- readRDS(system.file(\"extdata\", \"MouseBrainCoords.rds\",     package = \"SpNeigh\" )) logNorm_expr <- readRDS(system.file(\"extdata\", \"LogNormExpr.rds\",     package = \"SpNeigh\" ))  # Compute spatial weights and SEI bon_c0 <- getBoundary(data = coords, one_cluster = 0) cells_c0 <- subset(coords, cluster == 0)$cell weights <- computeBoundaryWeights(     data = coords,     cell_ids = cells_c0,     boundary = bon_c0 ) sei_df <- computeSpatialEnrichmentIndex(logNorm_expr[, cells_c0], weights) head(sei_df) #>      gene      SEI mean_expr normalized_SEI #> 1    Fmod 1.742086  1.562370       1.115027 #> 2    Gjb2 1.325063  1.193263       1.110452 #> 3 Aldh1a2 1.820161  1.642933       1.107872 #> 4 Slc13a4 2.106610  1.906511       1.104955 #> 5  Col1a1 1.842083  1.675953       1.099125 #> 6  Cyp1b1 1.495145  1.365958       1.094575"},{"path":"https://github.com/jinming-cheng/SpNeigh/reference/ComputeSpatialInteractionMatrix.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute a spatial neighborhood interaction matrix using K-nearest neighbors (KNN) — computeSpatialInteractionMatrix","title":"Compute a spatial neighborhood interaction matrix using K-nearest neighbors (KNN) — computeSpatialInteractionMatrix","text":"Computes spatial interaction matrix entry quantifies number neighboring cells given cluster (columns) among k-nearest neighbors cells another cluster (rows). provides summary spatial proximity enrichment neighboring clusters around focal cluster.","code":""},{"path":"https://github.com/jinming-cheng/SpNeigh/reference/ComputeSpatialInteractionMatrix.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute a spatial neighborhood interaction matrix using K-nearest neighbors (KNN) — computeSpatialInteractionMatrix","text":"","code":"computeSpatialInteractionMatrix(data = NULL, cluster_col = NULL, k = 10)"},{"path":"https://github.com/jinming-cheng/SpNeigh/reference/ComputeSpatialInteractionMatrix.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute a spatial neighborhood interaction matrix using K-nearest neighbors (KNN) — computeSpatialInteractionMatrix","text":"data Seurat object, SpatialExperiment object, data frame containing spatial coordinates. cluster_col Character scalar specifying metadata column name containing cluster assignments. NULL, default used depending input object type: \"seurat_clusters\" Seurat objects \"cluster\" SpatialExperiment objects k Integer. Number nearest neighbors use cell. Default 10.","code":""},{"path":"https://github.com/jinming-cheng/SpNeigh/reference/ComputeSpatialInteractionMatrix.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute a spatial neighborhood interaction matrix using K-nearest neighbors (KNN) — computeSpatialInteractionMatrix","text":"numeric matrix rows represent focal clusters columns represent neighboring clusters. cell matrix indicates frequently neighbor cluster appears among k-nearest neighbors cells focal cluster.","code":""},{"path":"https://github.com/jinming-cheng/SpNeigh/reference/ComputeSpatialInteractionMatrix.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Compute a spatial neighborhood interaction matrix using K-nearest neighbors (KNN) — computeSpatialInteractionMatrix","text":"matrix built identifying k nearest neighbors cell based spatial coordinates, tabulating cluster identities neighbors respect cluster identity focal cell.","code":""},{"path":"https://github.com/jinming-cheng/SpNeigh/reference/ComputeSpatialInteractionMatrix.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compute a spatial neighborhood interaction matrix using K-nearest neighbors (KNN) — computeSpatialInteractionMatrix","text":"","code":"# Load coordinates coords <- readRDS(system.file(\"extdata\", \"MouseBrainCoords.rds\",     package = \"SpNeigh\" ))  # Compute interaction matrix using all cells interaction_matrix <- computeSpatialInteractionMatrix(coords) head(interaction_matrix) #>       0     1     2     3     4     5    6   7   8   9   10  11 #> 0 26326  6590  5670  7847  4608  4212 2814 548 364 542  456 193 #> 1  6540 33843  2707  7455   607    15 5119   0   0   0   11 203 #> 2  5956  2774 30886  4694  5792  1908 1914 219  79 230 1393 155 #> 3  8572  7701  4895 11808  5558   901 3666 881 628 980  146 194 #> 4  4729   624  5754  5605 23932     0 3589   0   0   0    0   7 #> 5  4337    12  1682   849     0 29000   27   6   0   1    6   0  # Compute interaction matrix for cells inside boundaries boundary_points <- getBoundary(     data = coords, one_cluster = 2,     eps = 120, minPts = 10 ) cells_inside <- getCellsInside(data = coords, boundary = boundary_points) coords_sub <- subset(coords, cell %in% cells_inside$cell) computeSpatialInteractionMatrix(coords_sub) #>       0     2   3   4   5   6   10 #> 0  5115  1965  94  65  24  17  410 #> 2  2199 27625 923 558 187 201 1337 #> 3   100   893  50 136  22  16  133 #> 4    70   526 137 581   0  26    0 #> 5    25   129  18   0 942   0    6 #> 6    20   211  16  25   0  18   50 #> 10  416  1274 123   0   6  54 3987  # Compute interaction matrix for cells inside ring region 2 ring_regions <- getRingRegion(boundary = boundary_points, dist = 100) cells_ring <- getCellsInside(data = coords, boundary = ring_regions[2, ]) coords_sub <- subset(coords, cell %in% cells_ring$cell) computeSpatialInteractionMatrix(coords_sub) #>      0   2   3    5 6 7 #> 0 2634 219 230  476 8 3 #> 2  253 183  51  527 6 0 #> 3  304  52 230   66 7 1 #> 5  492 384  54 7479 1 0 #> 6    6   5   7    2 0 0 #> 7    4   0   6    0 0 0"},{"path":"https://github.com/jinming-cheng/SpNeigh/reference/ExtractCoords.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract spatial coordinates and cluster information — extractCoords","title":"Extract spatial coordinates and cluster information — extractCoords","text":"Extract spatial coordinates (optionally) cluster assignments Seurat object, SpatialExperiment object, user-supplied data frame.","code":""},{"path":"https://github.com/jinming-cheng/SpNeigh/reference/ExtractCoords.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract spatial coordinates and cluster information — extractCoords","text":"","code":"extractCoords(data, cluster_col = NULL, extract_cluster = TRUE)"},{"path":"https://github.com/jinming-cheng/SpNeigh/reference/ExtractCoords.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract spatial coordinates and cluster information — extractCoords","text":"data Seurat object, SpatialExperiment object, data frame containing spatial coordinates. cluster_col Character scalar specifying metadata column name containing cluster assignments. NULL, default used depending input object type: \"seurat_clusters\" Seurat objects \"cluster\" SpatialExperiment objects extract_cluster Logical indicating whether extract cluster information. FALSE, spatial coordinates cell IDs returned. Default TRUE.","code":""},{"path":"https://github.com/jinming-cheng/SpNeigh/reference/ExtractCoords.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extract spatial coordinates and cluster information — extractCoords","text":"data frame columns x, y, cell, optionally cluster extract_cluster = TRUE.","code":""},{"path":"https://github.com/jinming-cheng/SpNeigh/reference/ExtractCoords.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Extract spatial coordinates and cluster information — extractCoords","text":"Seurat objects, tissue coordinates obtained using Seurat::GetTissueCoordinates(), cluster labels taken specified metadata column (default seurat_clusters). SpatialExperiment objects, spatial coordinates obtained spatialCoords(), cluster labels taken colData() (default cluster column). data frame provided, must already contain columns named x, y, cell, cluster.","code":""},{"path":"https://github.com/jinming-cheng/SpNeigh/reference/ExtractCoords.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Extract spatial coordinates and cluster information — extractCoords","text":"","code":"coords <- readRDS(system.file(     \"extdata\", \"MouseBrainCoords.rds\",     package = \"SpNeigh\" ))  head(extractCoords(coords)) #>          x        y cell cluster #> 1 1898.815 2540.963    1       4 #> 2 1895.305 2532.627    2       4 #> 3 2368.073 2534.409    3       2 #> 4 1903.726 2560.010    4       4 #> 5 1917.481 2543.132    5       4 #> 6 1926.540 2560.044    6       4"},{"path":"https://github.com/jinming-cheng/SpNeigh/reference/FactorNaturalOrder.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a factor with natural (human-friendly) ordering — factorNaturalOrder","title":"Create a factor with natural (human-friendly) ordering — factorNaturalOrder","text":"Converts character numeric vector factor levels ordered naturally (e.g., a1, a2, ..., a10 instead lexicographically a1, a10, a2, ...). useful plotting labeling grouped data numeric substrings follow numeric order.","code":""},{"path":"https://github.com/jinming-cheng/SpNeigh/reference/FactorNaturalOrder.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a factor with natural (human-friendly) ordering — factorNaturalOrder","text":"","code":"factorNaturalOrder(x)"},{"path":"https://github.com/jinming-cheng/SpNeigh/reference/FactorNaturalOrder.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a factor with natural (human-friendly) ordering — factorNaturalOrder","text":"x character numeric vector convert factor natural order.","code":""},{"path":"https://github.com/jinming-cheng/SpNeigh/reference/FactorNaturalOrder.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a factor with natural (human-friendly) ordering — factorNaturalOrder","text":"factor levels sorted natural (human-readable) order.","code":""},{"path":"https://github.com/jinming-cheng/SpNeigh/reference/FactorNaturalOrder.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create a factor with natural (human-friendly) ordering — factorNaturalOrder","text":"","code":"# Numeric vector factorNaturalOrder(10:1) #>  [1] 10 9  8  7  6  5  4  3  2  1  #> Levels: 1 2 3 4 5 6 7 8 9 10  # Character vector with embedded numbers factorNaturalOrder(c(\"a11\", \"a12\", \"a1\", \"a2\", \"a\")) #> [1] a11 a12 a1  a2  a   #> Levels: a a1 a2 a11 a12"},{"path":"https://github.com/jinming-cheng/SpNeigh/reference/GetBoundary.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract spatial boundary points for a cluster or cell population — getBoundary","title":"Extract spatial boundary points for a cluster or cell population — getBoundary","text":"Identifies returns smoothed spatial boundary points specified cell cluster population using concave hull algorithm. function supports single-region multi-region boundaries. multi-region mode, subregions can detected automatically via DBSCAN manually using k-means clustering. Outlier cells first removed using k-nearest neighbor distance filter ensure boundary smoothness.","code":""},{"path":"https://github.com/jinming-cheng/SpNeigh/reference/GetBoundary.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract spatial boundary points for a cluster or cell population — getBoundary","text":"","code":"getBoundary(   data = NULL,   cluster_col = NULL,   one_cluster = NULL,   k = 5,   distance_cutoff = 30,   multi_region = TRUE,   subregion_method = c(\"dbscan\", \"kmeans\"),   eps = 80,   minPts = 10,   n_subregions = 3 )"},{"path":"https://github.com/jinming-cheng/SpNeigh/reference/GetBoundary.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract spatial boundary points for a cluster or cell population — getBoundary","text":"data Seurat object, SpatialExperiment object, data frame containing spatial coordinates. cluster_col Character scalar specifying metadata column name containing cluster assignments. NULL, default used depending input object type: \"seurat_clusters\" Seurat objects \"cluster\" SpatialExperiment objects one_cluster cluster ID (numeric character) extract boundary . k number nearest neighbors use computing local distances. Default 5. distance_cutoff numeric threshold average distance neighbors. Cells higher mean distance removed. Default 30. multi_region Logical. TRUE, identifies multiple spatial subregions within cluster. Default TRUE. subregion_method Subregion detection method multi_region = TRUE. Choose \"dbscan\" (automatic) \"kmeans\" (manual). Default \"dbscan\". eps Neighborhood radius DBSCAN subregion detection. used subregion_method = \"dbscan\". Default 80. minPts Minimum number points DBSCAN core point. used subregion_method = \"dbscan\". Default 10. n_subregions Number subregions use subregion_method = \"kmeans\". Default 3.","code":""},{"path":"https://github.com/jinming-cheng/SpNeigh/reference/GetBoundary.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extract spatial boundary points for a cluster or cell population — getBoundary","text":"data frame containing boundary points columns x, y, region_id. multi_region = TRUE, multiple boundaries returned labeled region_id. Otherwise, single boundary returned region_id = 1.","code":""},{"path":"https://github.com/jinming-cheng/SpNeigh/reference/GetBoundary.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Extract spatial boundary points for a cluster or cell population — getBoundary","text":"","code":"# Load coordinates coords <- readRDS(system.file(\"extdata\", \"MouseBrainCoords.rds\",     package = \"SpNeigh\" )) head(coords) #>          x        y cell cluster #> 1 1898.815 2540.963    1       4 #> 2 1895.305 2532.627    2       4 #> 3 2368.073 2534.409    3       2 #> 4 1903.726 2560.010    4       4 #> 5 1917.481 2543.132    5       4 #> 6 1926.540 2560.044    6       4  # Get boundary points of cluster 1 boundary_points <- getBoundary(data = coords, one_cluster = 1) head(boundary_points) #>          x        y region_id #> 1 447.7028 3404.517         1 #> 2 456.0788 3429.117         1 #> 3 475.1725 3440.692         1 #> 4 475.9918 3453.765         1 #> 5 466.2819 3466.096         1 #> 6 454.2985 3474.720         1  # Number of subregions table(boundary_points$region_id) #>  #>   1   2   3   4   5  #> 657 146  17  40   7   # Get boundary points of cluster 1 using kmeans method # and manually specify subregion number boundary_points <- getBoundary(     data = coords,     one_cluster = 1,     subregion_method = \"kmeans\",     n_subregions = 2 ) table(boundary_points$region_id) #>  #>   1   2  #> 353 538   # Get boundary points of cluster 1 without multiple regions boundary_points <- getBoundary(     data = coords,     one_cluster = 1,     multi_region = FALSE ) table(boundary_points$region_id) #>  #>   1  #> 853"},{"path":"https://github.com/jinming-cheng/SpNeigh/reference/GetCellsInside.html","id":null,"dir":"Reference","previous_headings":"","what":"Identify cells located within spatial boundaries or ring regions — getCellsInside","title":"Identify cells located within spatial boundaries or ring regions — getCellsInside","text":"Returns subset cells input data fall spatially within given boundary ring. boundary can provided either raw boundary points (getBoundary()), polygons (buildBoundaryPoly()), ring regions (getRingRegion()). function uses spatial point--polygon matching via sf::st_within.","code":""},{"path":"https://github.com/jinming-cheng/SpNeigh/reference/GetCellsInside.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Identify cells located within spatial boundaries or ring regions — getCellsInside","text":"","code":"getCellsInside(data = NULL, cluster_col = NULL, boundary = NULL)"},{"path":"https://github.com/jinming-cheng/SpNeigh/reference/GetCellsInside.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Identify cells located within spatial boundaries or ring regions — getCellsInside","text":"data Seurat object, SpatialExperiment object, data frame containing spatial coordinates. cluster_col Character scalar specifying metadata column name containing cluster assignments. NULL, default used depending input object type: \"seurat_clusters\" Seurat objects \"cluster\" SpatialExperiment objects boundary sf object (polygon ring) data frame boundary points returned getBoundary(), buildBoundaryPoly(), getRingRegion().","code":""},{"path":"https://github.com/jinming-cheng/SpNeigh/reference/GetCellsInside.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Identify cells located within spatial boundaries or ring regions — getCellsInside","text":"data frame (tibble) cells located inside given spatial region(s), region assignment region_id column.","code":""},{"path":"https://github.com/jinming-cheng/SpNeigh/reference/GetCellsInside.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Identify cells located within spatial boundaries or ring regions — getCellsInside","text":"","code":"# Load coordinates coords <- readRDS(system.file(\"extdata\", \"MouseBrainCoords.rds\",     package = \"SpNeigh\" )) head(coords) #>          x        y cell cluster #> 1 1898.815 2540.963    1       4 #> 2 1895.305 2532.627    2       4 #> 3 2368.073 2534.409    3       2 #> 4 1903.726 2560.010    4       4 #> 5 1917.481 2543.132    5       4 #> 6 1926.540 2560.044    6       4  # Get cells inside boundaries boundary_points <- getBoundary(     data = coords, one_cluster = 2,     eps = 120, minPts = 10 ) cells_inside <- getCellsInside(data = coords, boundary = boundary_points) cells_inside #> Simple feature collection with 5073 features and 3 fields #> Geometry type: POINT #> Dimension:     XY #> Bounding box:  xmin: 1590.613 ymin: 1640.136 xmax: 5443.607 ymax: 3531.379 #> CRS:           NA #> First 10 features: #>    cell cluster region_id                  geometry #> 3     3       2         1 POINT (2368.073 2534.409) #> 20   20       2         1 POINT (2456.959 2560.494) #> 31   31       2         1 POINT (2152.998 2554.538) #> 43   43       2         1 POINT (2312.183 2555.867) #> 44   44       2         1  POINT (2323.21 2551.805) #> 50   50       2         1 POINT (2356.391 2544.839) #> 52   52       2         1 POINT (2387.844 2537.827) #> 53   53       2         1 POINT (2401.216 2526.458) #> 54   54       2         1 POINT (2392.535 2555.696) #> 55   55       2         1 POINT (2407.538 2545.443)  # Get cells inside rings ring_regions <- getRingRegion(boundary = boundary_points, dist = 100) cells_ring <- getCellsInside(data = coords, boundary = ring_regions) cells_ring #> Simple feature collection with 4362 features and 3 fields #> Geometry type: POINT #> Dimension:     XY #> Bounding box:  xmin: 1482.997 ymin: 1530.545 xmax: 5441.679 ymax: 3532.463 #> CRS:           NA #> First 10 features: #>    cell cluster region_id                  geometry #> 21   21       4         1 POINT (2080.017 2559.984) #> 22   22       4         1 POINT (2088.025 2526.528) #> 23   23       2         1 POINT (2085.119 2546.843) #> 24   24       2         1 POINT (2101.906 2549.501) #> 25   25       4         1 POINT (2102.112 2540.185) #> 26   26       4         1 POINT (2089.812 2539.796) #> 27   27       4         1  POINT (2095.253 2533.08) #> 28   28       4         1  POINT (2100.02 2527.252) #> 29   29       4         1 POINT (2197.507 2524.511) #> 30   30       3         1 POINT (2209.931 2542.314)"},{"path":"https://github.com/jinming-cheng/SpNeigh/reference/GetInnerBoundary.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate an inner boundary polygon by shrinking an existing boundary inward — getInnerBoundary","title":"Generate an inner boundary polygon by shrinking an existing boundary inward — getInnerBoundary","text":"Computes inward-shifted (contracted) boundary applying negative spatial buffer existing boundary polygon. function wrapper around getOuterBoundary() useful defining inner region around spatial cluster structure.","code":""},{"path":"https://github.com/jinming-cheng/SpNeigh/reference/GetInnerBoundary.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate an inner boundary polygon by shrinking an existing boundary inward — getInnerBoundary","text":"","code":"getInnerBoundary(boundary = NULL, dist = 50)"},{"path":"https://github.com/jinming-cheng/SpNeigh/reference/GetInnerBoundary.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate an inner boundary polygon by shrinking an existing boundary inward — getInnerBoundary","text":"boundary data frame boundary points (columns x, y, region_id) sf object POLYGON geometries. dist positive numeric value specifying far inward shrink boundary. automatically converted negative buffer distance. Default 50.","code":""},{"path":"https://github.com/jinming-cheng/SpNeigh/reference/GetInnerBoundary.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate an inner boundary polygon by shrinking an existing boundary inward — getInnerBoundary","text":"sf object containing inward-shrunk polygons, one per region_id.","code":""},{"path":"https://github.com/jinming-cheng/SpNeigh/reference/GetInnerBoundary.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Generate an inner boundary polygon by shrinking an existing boundary inward — getInnerBoundary","text":"careful: shrinkage distance large, resulting geometry may become invalid disappear entirely, especially narrow irregular shapes.","code":""},{"path":[]},{"path":"https://github.com/jinming-cheng/SpNeigh/reference/GetInnerBoundary.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generate an inner boundary polygon by shrinking an existing boundary inward — getInnerBoundary","text":"","code":"# Load coordinates coords <- readRDS(system.file(\"extdata\", \"MouseBrainCoords.rds\",     package = \"SpNeigh\" ))  # Get boundary polygons of cluster 2 boundary_points <- getBoundary(data = coords, one_cluster = 2) boundary_polys <- buildBoundaryPoly(boundary_points) plot(boundary_polys)   # Generate inner boundary with 50-unit buffer for boundary region 1 inner_boundary <- getInnerBoundary(boundary_polys) #> Warning: Some inner boundaries may have collapsed or disappeared due to excessive shrinkage. plot(inner_boundary)"},{"path":"https://github.com/jinming-cheng/SpNeigh/reference/GetOuterBoundary.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate an outer or inner boundary polygon by buffering an existing boundary — getOuterBoundary","title":"Generate an outer or inner boundary polygon by buffering an existing boundary — getOuterBoundary","text":"Computes expanded shrunken boundary applying spatial buffer existing polygon. input can either boundary points (returned getBoundary()) polygon geometries (returned buildBoundaryPoly()). useful defining outer spatial neighborhoods shrinking boundaries inward define inner regions.","code":""},{"path":"https://github.com/jinming-cheng/SpNeigh/reference/GetOuterBoundary.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate an outer or inner boundary polygon by buffering an existing boundary — getOuterBoundary","text":"","code":"getOuterBoundary(boundary = NULL, dist = 100)"},{"path":"https://github.com/jinming-cheng/SpNeigh/reference/GetOuterBoundary.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate an outer or inner boundary polygon by buffering an existing boundary — getOuterBoundary","text":"boundary data frame boundary points (columns x, y, region_id) sf object. dist numeric value specifying buffer distance spatial units. Use positive values expand (outer boundary), negative values shrink (inner boundary). Default 100.","code":""},{"path":"https://github.com/jinming-cheng/SpNeigh/reference/GetOuterBoundary.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate an outer or inner boundary polygon by buffering an existing boundary — getOuterBoundary","text":"sf object expanded outer boundary polygons region_id values original input.","code":""},{"path":"https://github.com/jinming-cheng/SpNeigh/reference/GetOuterBoundary.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Generate an outer or inner boundary polygon by buffering an existing boundary — getOuterBoundary","text":"careful: using negative buffer distance (inner boundaries), polygons may collapse, become invalid, disappear entirely buffer width exceeds shape's interior size.","code":""},{"path":[]},{"path":"https://github.com/jinming-cheng/SpNeigh/reference/GetOuterBoundary.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generate an outer or inner boundary polygon by buffering an existing boundary — getOuterBoundary","text":"","code":"# Load coordinates coords <- readRDS(system.file(\"extdata\", \"MouseBrainCoords.rds\",     package = \"SpNeigh\" ))  # Get boundary points of cluster 2 boundary_points <- getBoundary(data = coords, one_cluster = 2)  # Build polygons from boundary points boundary_polys <- buildBoundaryPoly(boundary_points)  # Generate outer boundaries with 100-unit buffer outer1 <- getOuterBoundary(boundary_points, dist = 100) outer2 <- getOuterBoundary(boundary_polys, dist = 100)  # Plot original and expanded boundaries plot(boundary_polys) plot(outer2, add = TRUE, border = \"red\")"},{"path":"https://github.com/jinming-cheng/SpNeigh/reference/GetRingRegion.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate ring regions between a boundary and its outer buffer — getRingRegion","title":"Generate ring regions between a boundary and its outer buffer — getRingRegion","text":"Computes spatial ring-shaped regions subtracting original boundary polygons corresponding outer buffered polygons. outer_boundary supplied, automatically computed using getOuterBoundary(). useful analyzing periphery-enriched cell types gradient-based features near boundary.","code":""},{"path":"https://github.com/jinming-cheng/SpNeigh/reference/GetRingRegion.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate ring regions between a boundary and its outer buffer — getRingRegion","text":"","code":"getRingRegion(boundary = NULL, outer_boundary = NULL, ...)"},{"path":"https://github.com/jinming-cheng/SpNeigh/reference/GetRingRegion.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate ring regions between a boundary and its outer buffer — getRingRegion","text":"boundary data frame boundary points (columns x, y, region_id) sf object. outer_boundary Optional sf object containing buffered (outer) boundary polygons. provided, automatically computed using getOuterBoundary(). ... Additional arguments passed getOuterBoundary() outer_boundary provided.","code":""},{"path":"https://github.com/jinming-cheng/SpNeigh/reference/GetRingRegion.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate ring regions between a boundary and its outer buffer — getRingRegion","text":"sf object containing ring-shaped spatial regions generated subtracting inner boundary polygon corresponding outer boundary polygon.","code":""},{"path":"https://github.com/jinming-cheng/SpNeigh/reference/GetRingRegion.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generate ring regions between a boundary and its outer buffer — getRingRegion","text":"","code":"# Load coordinates coords <- readRDS(system.file(\"extdata\", \"MouseBrainCoords.rds\",     package = \"SpNeigh\" )) head(coords) #>          x        y cell cluster #> 1 1898.815 2540.963    1       4 #> 2 1895.305 2532.627    2       4 #> 3 2368.073 2534.409    3       2 #> 4 1903.726 2560.010    4       4 #> 5 1917.481 2543.132    5       4 #> 6 1926.540 2560.044    6       4  # Get boundary points of cluster 2 boundary_points <- getBoundary(data = coords, one_cluster = 2)  # Automatically compute outer boundary and get rings ring_regions <- getRingRegion(boundary = boundary_points, dist = 100) plot(ring_regions)   # Or provide both inner and outer boundaries explicitly outer <- getOuterBoundary(boundary_points, dist = 100) rings <- getRingRegion(boundary = boundary_points, outer_boundary = outer) plot(rings)"},{"path":"https://github.com/jinming-cheng/SpNeigh/reference/PlotBoundary.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot spatial cell coordinates with cluster boundaries — plotBoundary","title":"Plot spatial cell coordinates with cluster boundaries — plotBoundary","text":"Plots spatial cell locations overlays cluster population boundaries available. boundary provided one_cluster specified, boundary automatically generated using getBoundary() function. function supports plotting either clusters specific cluster using sub_plot = TRUE. Boundaries can overlaid polygons visualize spatial subregions.","code":""},{"path":"https://github.com/jinming-cheng/SpNeigh/reference/PlotBoundary.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot spatial cell coordinates with cluster boundaries — plotBoundary","text":"","code":"plotBoundary(   data = NULL,   cluster_col = NULL,   one_cluster = NULL,   boundary = NULL,   colors = colors15_cheng,   point_size = 0.5,   color_boundary = \"black\",   linewidth_boundary = 1.5,   sub_plot = FALSE,   split_by = NULL,   ncol = NULL,   angle_x_label = 0,   theme_ggplot = theme_spneigh(),   legend_size = 2,   ... )"},{"path":"https://github.com/jinming-cheng/SpNeigh/reference/PlotBoundary.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot spatial cell coordinates with cluster boundaries — plotBoundary","text":"data Seurat object, SpatialExperiment object, data frame containing spatial coordinates. cluster_col Character scalar specifying metadata column name containing cluster assignments. NULL, default used depending input object type: \"seurat_clusters\" Seurat objects \"cluster\" SpatialExperiment objects one_cluster cluster ID plot optionally compute boundary. Required sub_plot = TRUE boundary provided. boundary data frame columns x, y, region_id sf object POLYGON LINESTRING geometries. colors vector cluster colors. Default uses colors15_cheng. point_size Numeric. Size points representing cells. Default 0.5. color_boundary Color boundary lines. Default \"black\". linewidth_boundary Numeric. Line width boundary outlines. Default 1.5. sub_plot Logical. TRUE, cells specified one_cluster plotted. FALSE (default), clusters plotted. split_by Optional column name data facet plot (e.g., sample, condition). ncol Number columns faceted plot split_by used. Passed ggplot2::facet_wrap(). Default NULL, lets ggplot2 determine layout automatically. angle_x_label Numeric angle (degrees) rotate x-axis labels. Useful improving label readability faceted dense plots. Default 0 (rotation). theme_ggplot ggplot2 theme object. Default theme_spneigh(). legend_size Numeric. Size legend keys. Default 2. ... Additional arguments passed getBoundary auto-generating boundaries.","code":""},{"path":"https://github.com/jinming-cheng/SpNeigh/reference/PlotBoundary.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot spatial cell coordinates with cluster boundaries — plotBoundary","text":"ggplot object displaying spatial layout cells, optional boundary overlays.","code":""},{"path":"https://github.com/jinming-cheng/SpNeigh/reference/PlotBoundary.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot spatial cell coordinates with cluster boundaries — plotBoundary","text":"","code":"# Load coordinates coords <- readRDS(system.file(\"extdata\", \"MouseBrainCoords.rds\",     package = \"SpNeigh\" )) head(coords) #>          x        y cell cluster #> 1 1898.815 2540.963    1       4 #> 2 1895.305 2532.627    2       4 #> 3 2368.073 2534.409    3       2 #> 4 1903.726 2560.010    4       4 #> 5 1917.481 2543.132    5       4 #> 6 1926.540 2560.044    6       4  # Plot all cells without boundaries plotBoundary(coords)   # Plot one cluster and its boundary plotBoundary(coords, one_cluster = 2)   # Manually compute boundary and plot boundary_points <- getBoundary(     data = coords, one_cluster = 2,     eps = 120, minPts = 10 ) plotBoundary(data = coords, boundary = boundary_points)   # plotBoundary for a SpatialExperiment object logNorm_expr <- readRDS(system.file(\"extdata\", \"LogNormExpr.rds\",     package = \"SpNeigh\" )) coords_sub <- subset(coords, cluster %in% c(\"0\", \"2\")) coords_sub <- as.matrix(coords_sub[, c(\"x\", \"y\")]) metadata_sub <- subset(     coords[, c(\"cell\", \"cluster\")],     cluster %in% c(\"0\", \"2\") )  spe <- SpatialExperiment::SpatialExperiment(     assay = list(\"logcounts\" = logNorm_expr),     colData = metadata_sub,     spatialCoords = coords_sub )  plotBoundary(data = spe, one_cluster = 2)   # plotBoundary for a Seurat object seu_sp <- Seurat::CreateSeuratObject(     assay = \"Spatial\",     counts = logNorm_expr,     meta.data = metadata_sub ) SeuratObject::LayerData(seu_sp,     assay = \"Spatial\",     layer = \"data\" ) <- logNorm_expr  cents <- SeuratObject::CreateCentroids(coords_sub[, c(\"x\", \"y\")]) fov <- SeuratObject::CreateFOV(     coords = list(\"centroids\" = cents),     type = c(\"centroids\"),     assay = \"Spatial\" ) seu_sp[[\"fov\"]] <- fov  seu_sp$seurat_clusters <- seu_sp$cluster  plotBoundary(data = seu_sp, one_cluster = 2, eps = 120)"},{"path":"https://github.com/jinming-cheng/SpNeigh/reference/PlotCellsInside.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot cells located within spatial boundaries or ring regions — plotCellsInside","title":"Plot cells located within spatial boundaries or ring regions — plotCellsInside","text":"Visualizes cells fall within defined spatial regions (boundaries rings), typically obtained using getCellsInside() function. cells colored cluster, function offers two plotting modes: using geom_sf() (fixed 1:1 aspect ratio) geom_point() (flexible layout).","code":""},{"path":"https://github.com/jinming-cheng/SpNeigh/reference/PlotCellsInside.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot cells located within spatial boundaries or ring regions — plotCellsInside","text":"","code":"plotCellsInside(   cells_inside = NULL,   point_size = 0.5,   colors = colors15_cheng,   theme_ggplot = theme_spneigh(),   legend_size = 2,   fixed_aspect_ratio = TRUE )"},{"path":"https://github.com/jinming-cheng/SpNeigh/reference/PlotCellsInside.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot cells located within spatial boundaries or ring regions — plotCellsInside","text":"cells_inside sf object cells returned getCellsInside(). Must contain cluster region_id columns. point_size Numeric. Size points representing cells. Default 0.5. colors vector cluster colors. Default uses colors15_cheng. theme_ggplot ggplot2 theme object. Default theme_spneigh(). legend_size Numeric. Size legend keys. Default 2. fixed_aspect_ratio Logical. TRUE, uses geom_sf() preserve spatial scale. FALSE, uses geom_point() extracted coordinates. Default TRUE.","code":""},{"path":"https://github.com/jinming-cheng/SpNeigh/reference/PlotCellsInside.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot cells located within spatial boundaries or ring regions — plotCellsInside","text":"ggplot object showing cells colored cluster within spatial regions.","code":""},{"path":"https://github.com/jinming-cheng/SpNeigh/reference/PlotCellsInside.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot cells located within spatial boundaries or ring regions — plotCellsInside","text":"","code":"coords <- readRDS(system.file(\"extdata\", \"MouseBrainCoords.rds\",     package = \"SpNeigh\" ))  # Plot cells inside boundaries boundary_points <- getBoundary(data = coords, one_cluster = 2) cells_inside <- getCellsInside(data = coords, boundary = boundary_points) plotCellsInside(cells_inside)   # Plot cells inside rings ring_regions <- getRingRegion(boundary = boundary_points, dist = 100) cells_ring <- getCellsInside(data = coords, boundary = ring_regions) plotCellsInside(cells_ring, fixed_aspect_ratio = FALSE)"},{"path":"https://github.com/jinming-cheng/SpNeigh/reference/PlotEdge.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot boundary edges or segmented boundary lines — plotEdge","title":"Plot boundary edges or segmented boundary lines — plotEdge","text":"Plots boundary edges colored LINESTRING POLYGON outlines using ggplot2. function especially useful visualizing specific edges extracted polygon using splitBoundaryPolyByAnchor().","code":""},{"path":"https://github.com/jinming-cheng/SpNeigh/reference/PlotEdge.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot boundary edges or segmented boundary lines — plotEdge","text":"","code":"plotEdge(   boundary_poly = NULL,   linewidth_boundary = 1,   theme_ggplot = theme_spneigh(),   ... )"},{"path":"https://github.com/jinming-cheng/SpNeigh/reference/PlotEdge.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot boundary edges or segmented boundary lines — plotEdge","text":"boundary_poly sf object containing POLYGON LINESTRING geometries region_id column. linewidth_boundary Numeric value specifying line width edge. Default 1. theme_ggplot ggplot2 theme object. Default theme_spneigh(). ... Additional arguments passed ggplot2::geom_sf().","code":""},{"path":"https://github.com/jinming-cheng/SpNeigh/reference/PlotEdge.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot boundary edges or segmented boundary lines — plotEdge","text":"ggplot object displaying edge outlines colored region_id.","code":""},{"path":"https://github.com/jinming-cheng/SpNeigh/reference/PlotEdge.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot boundary edges or segmented boundary lines — plotEdge","text":"","code":"coords <- readRDS(system.file(\"extdata\", \"MouseBrainCoords.rds\",     package = \"SpNeigh\" ))  # Build boundary polygon and plot its outline boundary_points <- getBoundary(     data = coords, one_cluster = 2,     eps = 120, minPts = 10 ) boundary_polys <- buildBoundaryPoly(boundary_points) plotEdge(boundary_poly = boundary_polys)   # Split a polygon into edge segments and plot boundary_edges <- splitBoundaryPolyByAnchor(boundary_polys[1, ]) plotEdge(boundary_poly = boundary_edges)"},{"path":"https://github.com/jinming-cheng/SpNeigh/reference/PlotExpression.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot gene expression across spatial coordinates — plotExpression","title":"Plot gene expression across spatial coordinates — plotExpression","text":"Visualizes expression selected genes spatial plot using cell coordinates expression matrix. Can display expression cells subset (e.g., cluster manually specified cells). Also supports splitting plot using metadata columns (e.g., cluster) returning either combined plot list individual ggplot objects.","code":""},{"path":"https://github.com/jinming-cheng/SpNeigh/reference/PlotExpression.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot gene expression across spatial coordinates — plotExpression","text":"","code":"plotExpression(   data = NULL,   exp_mat = NULL,   genes = NULL,   sub_plot = FALSE,   cluster_col = NULL,   one_cluster = NULL,   sub_cells = NULL,   split_by = NULL,   ncol = NULL,   return_list = FALSE,   point_size = 0.2,   angle_x_label = 0,   shuffle = FALSE,   theme_ggplot = theme_spneigh() )"},{"path":"https://github.com/jinming-cheng/SpNeigh/reference/PlotExpression.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot gene expression across spatial coordinates — plotExpression","text":"data Seurat object, SpatialExperiment object, data frame containing spatial coordinates. exp_mat numeric gene expression matrix genes rows cells columns. Must class matrix dgCMatrix. data Seurat object, exp_mat can omitted automatically extracted using Seurat::GetAssayData() active assay. data SpatialExperiment object, exp_mat can omitted automatically extracted SingleCellExperiment::logcounts(). column names exp_mat must match cell identifiers used downstream analyses. genes Character vector specifying gene names plotted. Must match row names exp_mat. sub_plot Logical. TRUE, subset cells plotted (based one_cluster sub_cells). Default FALSE. cluster_col Character scalar specifying metadata column name containing cluster assignments. NULL, default used depending input object type: \"seurat_clusters\" Seurat objects \"cluster\" SpatialExperiment objects one_cluster Optional. Cluster ID subset cells sub_plot = TRUE. sub_cells Optional. Vector cell IDs include plot sub_plot = TRUE. one_cluster sub_cells provided, intersection used. split_by Optional. Column name metadata (data) facet plots (e.g., cluster). ncol Number columns faceted plot split_by used. Passed ggplot2::facet_wrap(). Default NULL, lets ggplot2 determine layout automatically. return_list Logical. TRUE, returns named list individual ggplot objects per gene. FALSE (default), plots wrapped single patchwork layout. point_size Numeric. Size plotted points. Default 0.2. angle_x_label Numeric angle (degrees) rotate x-axis labels. Useful improving label readability faceted dense plots. Default 0 (rotation). shuffle Logical. TRUE, shuffles cell order plotting. Otherwise, cells higher expression plotted top. Default FALSE. theme_ggplot ggplot2 theme object. Default theme_spneigh().","code":""},{"path":"https://github.com/jinming-cheng/SpNeigh/reference/PlotExpression.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot gene expression across spatial coordinates — plotExpression","text":"patchwork object list ggplot objects return_list = TRUE.","code":""},{"path":"https://github.com/jinming-cheng/SpNeigh/reference/PlotExpression.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot gene expression across spatial coordinates — plotExpression","text":"","code":"df <- data.frame(     x = c(rnorm(100, 1), rnorm(100, 5)),     y = c(rnorm(100, 1), rnorm(100, 5)),     cell = 1:200,     cluster = rep(1:2, each = 100) ) exp_mat <- data.frame(     gene1 = c(runif(100, 4, 6), runif(100, 0, 2)),     gene2 = c(runif(100, 0, 1), runif(100, 5, 8)) )  exp_mat <- t(exp_mat) colnames(exp_mat) <- df$cell  # set a random seed when shuffle is TRUE to reproduce the plot set.seed(123) plotExpression(     data = df, exp_mat = exp_mat, shuffle = TRUE,     genes = c(\"gene1\", \"gene2\"), point_size = 2 )   plotExpression(     data = df, exp_mat = exp_mat,     genes = \"gene1\", sub_plot = TRUE,     one_cluster = 1, point_size = 2 )"},{"path":"https://github.com/jinming-cheng/SpNeigh/reference/PlotInteractionMatrix.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot a heatmap of a row-scaled spatial interaction matrix — plotInteractionMatrix","title":"Plot a heatmap of a row-scaled spatial interaction matrix — plotInteractionMatrix","text":"Visualizes spatial interaction matrix using heatmap, rows represent focal clusters columns represent neighbor clusters. row scaled using z-scores highlight relative enrichment patterns across neighbor types. useful detecting spatial proximity patterns cell populations.","code":""},{"path":"https://github.com/jinming-cheng/SpNeigh/reference/PlotInteractionMatrix.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot a heatmap of a row-scaled spatial interaction matrix — plotInteractionMatrix","text":"","code":"plotInteractionMatrix(   interaction_matrix = NULL,   low_color = \"blue\",   mid_color = \"white\",   high_color = \"red\",   angle_x_label = 45,   title = \"Row-Scaled Interaction Matrix (Z-scores)\" )"},{"path":"https://github.com/jinming-cheng/SpNeigh/reference/PlotInteractionMatrix.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot a heatmap of a row-scaled spatial interaction matrix — plotInteractionMatrix","text":"interaction_matrix numeric matrix focal clusters rows neighbor clusters columns. Typically output computeSpatialInteractionMatrix(). low_color Color representing low z-score values. Default \"blue\". mid_color Color representing midpoint (z-score = 0). Default \"white\". high_color Color representing high z-score values. Default \"red\". angle_x_label Angle (degrees) rotate x-axis labels. Default 45. title Title heatmap.","code":""},{"path":"https://github.com/jinming-cheng/SpNeigh/reference/PlotInteractionMatrix.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot a heatmap of a row-scaled spatial interaction matrix — plotInteractionMatrix","text":"ggplot object representing row-scaled heatmap interaction matrix.","code":""},{"path":"https://github.com/jinming-cheng/SpNeigh/reference/PlotInteractionMatrix.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot a heatmap of a row-scaled spatial interaction matrix — plotInteractionMatrix","text":"","code":"coords <- readRDS(system.file(\"extdata\", \"MouseBrainCoords.rds\",     package = \"SpNeigh\" ))  boundary_points <- getBoundary(     data = coords, one_cluster = 2,     eps = 120, minPts = 10 ) ring_regions <- getRingRegion(boundary = boundary_points, dist = 100) cells_ring <- getCellsInside(data = coords, boundary = ring_regions) coords_sub <- subset(coords, cell %in% cells_ring$cell) interaction_matrix <- computeSpatialInteractionMatrix(coords_sub)  plotInteractionMatrix(interaction_matrix)"},{"path":"https://github.com/jinming-cheng/SpNeigh/reference/PlotRegion.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot filled spatial regions inside boundaries or rings — plotRegion","title":"Plot filled spatial regions inside boundaries or rings — plotRegion","text":"Creates ggplot spatial regions (e.g., subregions ring areas) using filled polygons. region automatically assigned fill color based region_id. function commonly used visualize area inside spatial boundaries surrounding rings, created buildBoundaryPoly() getRingRegion().","code":""},{"path":"https://github.com/jinming-cheng/SpNeigh/reference/PlotRegion.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot filled spatial regions inside boundaries or rings — plotRegion","text":"","code":"plotRegion(   boundary_poly = NULL,   alpha = 0.5,   color_boundary = \"black\",   linewidth_boundary = 1,   theme_ggplot = theme_spneigh(),   ... )"},{"path":"https://github.com/jinming-cheng/SpNeigh/reference/PlotRegion.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot filled spatial regions inside boundaries or rings — plotRegion","text":"boundary_poly sf object POLYGON geometries containing region_id column. Typically created buildBoundaryPoly() getRingRegion(). alpha Numeric value controlling transparency filled regions. Default 0.5. color_boundary Color region outlines. Default \"black\". linewidth_boundary Numeric line width region borders. Default 1. theme_ggplot ggplot2 theme object. Default theme_spneigh(). ... Additional arguments passed ggplot2::geom_sf().","code":""},{"path":"https://github.com/jinming-cheng/SpNeigh/reference/PlotRegion.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot filled spatial regions inside boundaries or rings — plotRegion","text":"ggplot object displaying filled spatial regions region_id.","code":""},{"path":"https://github.com/jinming-cheng/SpNeigh/reference/PlotRegion.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot filled spatial regions inside boundaries or rings — plotRegion","text":"","code":"coords <- readRDS(system.file(\"extdata\", \"MouseBrainCoords.rds\",     package = \"SpNeigh\" ))  # Plot filled boundary regions boundary_points <- getBoundary(     data = coords, one_cluster = 2,     eps = 120, minPts = 10 ) boundary_polys <- buildBoundaryPoly(boundary_points) plotRegion(boundary_poly = boundary_polys)   # Plot filled ring regions ring_regions <- getRingRegion(boundary = boundary_points, dist = 100) plotRegion(boundary_poly = ring_regions)"},{"path":"https://github.com/jinming-cheng/SpNeigh/reference/PlotSpatialExpression.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot average gene expression along spatial distance — plotSpatialExpression","title":"Plot average gene expression along spatial distance — plotSpatialExpression","text":"Visualizes average expression specified genes varies along spatial distance gradient. spatial distance binned, average expression within bin plotted heatmap.","code":""},{"path":"https://github.com/jinming-cheng/SpNeigh/reference/PlotSpatialExpression.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot average gene expression along spatial distance — plotSpatialExpression","text":"","code":"plotSpatialExpression(   exp_mat = NULL,   spatial_distance = NULL,   genes = NULL,   n_bins = 50,   scale_method = c(\"none\", \"zscore\", \"minmax\"),   n_labels = 6,   row_gap = 0.1,   column_gap = 0,   label_x = \"Spatial distance\",   label_y = \"Gene\",   theme_ggplot = theme_spneigh() )"},{"path":"https://github.com/jinming-cheng/SpNeigh/reference/PlotSpatialExpression.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot average gene expression along spatial distance — plotSpatialExpression","text":"exp_mat normalized gene expression matrix (genes x cells), either matrix dgCMatrix. Typically log-normalized counts, e.g., Seurat object. spatial_distance named numeric vector containing spatial distance (weights) cell. genes Character vector specifying gene names plotted. Must match row names exp_mat. n_bins Integer. Number bins divide spatial distance . Default 50. scale_method string indicating scale average expression values across bins gene. Options : \"none\" scaling (default). average expression plotted -. \"zscore\" Standardize expression (mean 0, SD 1) per gene using scale(). \"minmax\" Normalize expression [0, 1] range per gene using scales::rescale(). n_labels Integer. Number axis labels show along distance axis. Default 6. row_gap Numeric 0 (inclusive) 1 (exclusive). Gap rows (genes) plot. Default 0.1. column_gap Numeric 0 (inclusive) 1 (exclusive). Gap columns (distance bins) plot. Default 0. label_x Character. Label x-axis. Default \"Spatial distance\". label_y Character. Label y-axis. Default \"Gene\". theme_ggplot ggplot2 theme object. Default theme_spneigh().","code":""},{"path":"https://github.com/jinming-cheng/SpNeigh/reference/PlotSpatialExpression.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot average gene expression along spatial distance — plotSpatialExpression","text":"ggplot2 object displaying heatmap binned average gene expression across spatial distances.","code":""},{"path":"https://github.com/jinming-cheng/SpNeigh/reference/PlotSpatialExpression.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot average gene expression along spatial distance — plotSpatialExpression","text":"","code":"# Example spatial expression heatmap set.seed(1) exp_mat <- matrix(runif(1000), nrow = 10) rownames(exp_mat) <- paste0(\"Gene\", 1:10) spatial_distance <- runif(100) plotSpatialExpression(     exp_mat = exp_mat,     spatial_distance = spatial_distance,     genes = rownames(exp_mat)[1:5] )"},{"path":"https://github.com/jinming-cheng/SpNeigh/reference/PlotStatsBar.html","id":null,"dir":"Reference","previous_headings":"","what":"Bar plot of cluster statistics for cells inside boundaries or ring regions — plotStatsBar","title":"Bar plot of cluster statistics for cells inside boundaries or ring regions — plotStatsBar","text":"Creates bar plot visualize distribution cells inside spatial regions (e.g., boundaries rings), either raw counts proportions per cluster. plot faceted region_id show statistics across multiple spatial subregions.","code":""},{"path":"https://github.com/jinming-cheng/SpNeigh/reference/PlotStatsBar.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Bar plot of cluster statistics for cells inside boundaries or ring regions — plotStatsBar","text":"","code":"plotStatsBar(   cell_stats = NULL,   stat_column = c(\"proportion\", \"count\"),   colors = colors15_cheng,   angle_x_label = 0,   theme_ggplot = theme_spneigh() )"},{"path":"https://github.com/jinming-cheng/SpNeigh/reference/PlotStatsBar.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Bar plot of cluster statistics for cells inside boundaries or ring regions — plotStatsBar","text":"cell_stats data frame containing summarized cell statistics, typically output statsCellsInside(). Must include columns region_id, cluster, specified stat_column. stat_column Character. Column name cell_stats use y-axis. Options \"count\" (number cells) \"proportion\" (relative fraction per region). colors vector cluster colors. Default uses colors15_cheng. angle_x_label Numeric angle (degrees) rotate x-axis labels. Useful improving label readability faceted dense plots. Default 0 (rotation). theme_ggplot ggplot2 theme object. Default theme_spneigh().","code":""},{"path":"https://github.com/jinming-cheng/SpNeigh/reference/PlotStatsBar.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Bar plot of cluster statistics for cells inside boundaries or ring regions — plotStatsBar","text":"ggplot2 object showing faceted bar plot cell statistics per region.","code":""},{"path":"https://github.com/jinming-cheng/SpNeigh/reference/PlotStatsBar.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Bar plot of cluster statistics for cells inside boundaries or ring regions — plotStatsBar","text":"","code":"coords <- readRDS(system.file(\"extdata\", \"MouseBrainCoords.rds\",     package = \"SpNeigh\" ))  boundary_points <- getBoundary(     data = coords, one_cluster = 2,     eps = 120, minPts = 10 ) cells_inside <- getCellsInside(data = coords, boundary = boundary_points) stats_cells <- statsCellsInside(cells_inside)  plotStatsBar(stats_cells, stat_column = \"proportion\")  plotStatsBar(stats_cells, stat_column = \"count\")"},{"path":"https://github.com/jinming-cheng/SpNeigh/reference/PlotStatsPie.html","id":null,"dir":"Reference","previous_headings":"","what":"Pie chart or donut chart of cluster proportions inside spatial regions — plotStatsPie","title":"Pie chart or donut chart of cluster proportions inside spatial regions — plotStatsPie","text":"Generates pie donut charts visualize proportion cells different clusters within spatial region (e.g., boundary ring). plot faceted region_id show composition spatial subregion. Optionally, percentage labels can added filtering based minimum proportion threshold.","code":""},{"path":"https://github.com/jinming-cheng/SpNeigh/reference/PlotStatsPie.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Pie chart or donut chart of cluster proportions inside spatial regions — plotStatsPie","text":"","code":"plotStatsPie(   cell_stats = NULL,   plot_donut = FALSE,   add_labels = TRUE,   label_cutoff = 0.01,   label_color = \"white\",   label_size = 4,   label_nudge_x = 0.1,   colors = colors15_cheng )"},{"path":"https://github.com/jinming-cheng/SpNeigh/reference/PlotStatsPie.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Pie chart or donut chart of cluster proportions inside spatial regions — plotStatsPie","text":"cell_stats data frame containing cluster statistics per region, typically output statsCellsInside(). Must include columns region_id, cluster, proportion. plot_donut Logical. TRUE, donut chart generated; otherwise, pie chart. Default FALSE. add_labels Logical. TRUE, percentage labels displayed inside slice. Default TRUE. label_cutoff Numeric. Proportional threshold labels hidden (e.g., 0.01 = 1%). Default 0.01. label_color Character. Color percentage labels. Default \"white\". label_size Numeric. Text size percentage labels. Default 4. label_nudge_x Numeric. Horizontal adjustment label positioning. Default 0.1. colors vector cluster colors. Default uses colors15_cheng.","code":""},{"path":"https://github.com/jinming-cheng/SpNeigh/reference/PlotStatsPie.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Pie chart or donut chart of cluster proportions inside spatial regions — plotStatsPie","text":"ggplot2 object representing faceted pie donut chart per spatial region.","code":""},{"path":"https://github.com/jinming-cheng/SpNeigh/reference/PlotStatsPie.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Pie chart or donut chart of cluster proportions inside spatial regions — plotStatsPie","text":"","code":"coords <- readRDS(system.file(\"extdata\", \"MouseBrainCoords.rds\",     package = \"SpNeigh\" ))  boundary_points <- getBoundary(     data = coords, one_cluster = 2,     eps = 120, minPts = 10 ) cells_inside <- getCellsInside(data = coords, boundary = boundary_points) stats_cells <- statsCellsInside(cells_inside)  plotStatsPie(stats_cells, add_labels = FALSE)  plotStatsPie(stats_cells, label_cutoff = 0)  plotStatsPie(stats_cells, label_cutoff = 0.01)  plotStatsPie(stats_cells, plot_donut = TRUE)"},{"path":"https://github.com/jinming-cheng/SpNeigh/reference/PlotWeights.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot spatial weights for cells on a spatial plot — plotWeights","title":"Plot spatial weights for cells on a spatial plot — plotWeights","text":"Visualizes spatial weights plotting cell coordinates colored numeric weight value. cells data match names weights included. useful visualizing spatial trends proximity boundaries centroids.","code":""},{"path":"https://github.com/jinming-cheng/SpNeigh/reference/PlotWeights.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot spatial weights for cells on a spatial plot — plotWeights","text":"","code":"plotWeights(   data = NULL,   weights = NULL,   point_size = 0.2,   theme_ggplot = theme_spneigh() )"},{"path":"https://github.com/jinming-cheng/SpNeigh/reference/PlotWeights.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot spatial weights for cells on a spatial plot — plotWeights","text":"data data frame, Seurat object SpatialExperiment object containing spatial coordinates. Must include columns: cell, x, y. weights named numeric vector spatial weights, cell IDs names. point_size Numeric. Point size cells plot. Default 0.2. theme_ggplot ggplot2 theme object. Default theme_spneigh().","code":""},{"path":"https://github.com/jinming-cheng/SpNeigh/reference/PlotWeights.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot spatial weights for cells on a spatial plot — plotWeights","text":"ggplot2 object displaying scatter plot cells colored weights.","code":""},{"path":"https://github.com/jinming-cheng/SpNeigh/reference/PlotWeights.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot spatial weights for cells on a spatial plot — plotWeights","text":"","code":"# Load coordinate data coords <- readRDS(system.file(\"extdata\", \"MouseBrainCoords.rds\",     package = \"SpNeigh\" ))  # Cells in cluster 2 cells_c2 <- subset(coords, cluster == 2)[, \"cell\"]  # Compute centroid weights and plot weights_cen <- computeCentroidWeights(data = coords, cell_ids = cells_c2) plotWeights(data = coords, weights = weights_cen)   # Compute boundary weights and plot boundary_points <- getBoundary(data = coords, one_cluster = 2) weights_bon <- computeBoundaryWeights(     data = coords, cell_ids = cells_c2,     boundary = boundary_points ) plotWeights(data = coords, weights = weights_bon)"},{"path":"https://github.com/jinming-cheng/SpNeigh/reference/RemoveOutliers.html","id":null,"dir":"Reference","previous_headings":"","what":"Removes spatial outlier cells based on local k-nearest neighbor distances — removeOutliers","title":"Removes spatial outlier cells based on local k-nearest neighbor distances — removeOutliers","text":"Identifies removes spatial outliers based local density. cell, average distance k nearest neighbors computed. Cells mean k-NN distance greater specified cutoff considered outliers removed. helps retain densely connected cells filtering isolated ones.","code":""},{"path":"https://github.com/jinming-cheng/SpNeigh/reference/RemoveOutliers.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Removes spatial outlier cells based on local k-nearest neighbor distances — removeOutliers","text":"","code":"removeOutliers(coords, k = 5, distance_cutoff = 30)"},{"path":"https://github.com/jinming-cheng/SpNeigh/reference/RemoveOutliers.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Removes spatial outlier cells based on local k-nearest neighbor distances — removeOutliers","text":"coords data frame matrix cell coordinates. k number nearest neighbors use computing local distances. Default 5. distance_cutoff numeric threshold average distance neighbors. Cells higher mean distance removed. Default 30.","code":""},{"path":"https://github.com/jinming-cheng/SpNeigh/reference/RemoveOutliers.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Removes spatial outlier cells based on local k-nearest neighbor distances — removeOutliers","text":"data frame containing filtered coordinates additional column: mean_knn_dist: average distance k nearest neighbors point. points mean_knn_dist less specified distance_cutoff retained.","code":""},{"path":"https://github.com/jinming-cheng/SpNeigh/reference/RemoveOutliers.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Removes spatial outlier cells based on local k-nearest neighbor distances — removeOutliers","text":"","code":"# Set seed for reproducibility set.seed(123)  # Generate 20 clustered points n1 <- 20 x1 <- rnorm(n1, mean = 5, sd = 0.5) y1 <- rnorm(n1, mean = 5, sd = 0.5)  # Generate 5 outliers n2 <- 5 x2 <- runif(n2, min = 10, max = 15) y2 <- runif(n2, min = 10, max = 15)  # Combine clustered points and outliers coords <- data.frame(x = c(x1, x2), y = c(y1, y2)) dim(coords) #> [1] 25  2  # Plot clustered points and outlier points plot(coords$x, coords$y,     pch = 16,     col = rep(c(\"red\", \"green\"), times = c(20, 5)) )   # Remove outlier points with a specified knn distance cutoff new_coords <- removeOutliers(coords, k = 5, distance_cutoff = 2) dim(new_coords) #> [1] 20  3  # Returns TRUE meaning outliers have been removed in new_coords all((new_coords$x == x1) & (new_coords$y == y1)) #> [1] TRUE"},{"path":"https://github.com/jinming-cheng/SpNeigh/reference/RunLimmaDE.html","id":null,"dir":"Reference","previous_headings":"","what":"Differential expression analysis between two groups of cells using limma — runLimmaDE","title":"Differential expression analysis between two groups of cells using limma — runLimmaDE","text":"Performs differential expression analysis two groups cells using limma linear modeling framework. Supports optional observation-level weights (e.g., spatial weights) filters genes minimum expression threshold across groups.","code":""},{"path":"https://github.com/jinming-cheng/SpNeigh/reference/RunLimmaDE.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Differential expression analysis between two groups of cells using limma — runLimmaDE","text":"","code":"runLimmaDE(   exp_mat = NULL,   cells_reference = NULL,   cells_target = NULL,   weights = NULL,   adj_p.value = 0.05,   min.pct = 0 )"},{"path":"https://github.com/jinming-cheng/SpNeigh/reference/RunLimmaDE.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Differential expression analysis between two groups of cells using limma — runLimmaDE","text":"exp_mat normalized gene expression matrix (genes x cells), either matrix dgCMatrix. Typically log-normalized counts, e.g., Seurat object. cells_reference character vector cell IDs use reference (baseline) group. cells_target character vector cell IDs use target (comparison) group. weights Optional numeric vector observation-level weights. Must named cell IDs match length cells_reference + cells_target. adj_p.value Adjusted p-value threshold reporting differentially expressed genes. Default 0.05. min.pct Minimum proportion cells expressing gene either group (values 0 1). Genes meeting threshold excluded testing. Default 0.","code":""},{"path":"https://github.com/jinming-cheng/SpNeigh/reference/RunLimmaDE.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Differential expression analysis between two groups of cells using limma — runLimmaDE","text":"data frame differentially expressed genes, sorted absolute log fold change. Includes columns: logFC Log2 fold change expression (target vs. reference) AveExpr Average expression across groups t, P.Value, adj.P.Val, B Statistical results limma pct.reference Proportion reference cells expressing gene pct.target Proportion target cells expressing gene gene Gene name (rownames exp_mat)","code":""},{"path":"https://github.com/jinming-cheng/SpNeigh/reference/RunLimmaDE.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Differential expression analysis between two groups of cells using limma — runLimmaDE","text":"","code":"# Load coordinates and log-normalized expression data coords <- readRDS(system.file(\"extdata\", \"MouseBrainCoords.rds\",     package = \"SpNeigh\" )) logNorm_expr <- readRDS(system.file(\"extdata\", \"LogNormExpr.rds\",     package = \"SpNeigh\" ))  # Subset cells from cluster 0 and 2 cells_ref <- subset(coords, cluster == 0)$cell cells_tar <- subset(coords, cluster == 2)$cell  # Run differential expression with minimum expression threshold tab <- runLimmaDE(     exp_mat = logNorm_expr,     cells_reference = cells_ref,     cells_target = cells_tar,     min.pct = 0.25 )  head(tab[, c(\"gene\", \"logFC\", \"adj.P.Val\", \"pct.reference\", \"pct.target\")]) #>          gene     logFC adj.P.Val pct.reference pct.target #> Gjc3     Gjc3  4.502163         0    0.25993020  0.9000000 #> Sox10   Sox10  4.147574         0    0.08259930  0.8078571 #> Fn1       Fn1 -3.769727         0    0.79707495  0.1539286 #> Opalin Opalin  3.694963         0    0.06847266  0.6757143 #> Cldn5   Cldn5 -3.472197         0    0.68140269  0.0900000 #> Ly6a     Ly6a -3.290134         0    0.77829483  0.2583929"},{"path":"https://github.com/jinming-cheng/SpNeigh/reference/RunSpatialDE.html","id":null,"dir":"Reference","previous_headings":"","what":"Differential expression along spatial distance gradients using splines — runSpatialDE","title":"Differential expression along spatial distance gradients using splines — runSpatialDE","text":"Performs spatially-aware differential expression (DE) analysis modeling gene expression smooth function continuous spatial covariate (e.g., distance boundary centroid). Natural spline basis functions used capture non-linear trends expression relative spatial distance. method suitable identifying genes whose expression varies continuously across spatial structures.","code":""},{"path":"https://github.com/jinming-cheng/SpNeigh/reference/RunSpatialDE.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Differential expression along spatial distance gradients using splines — runSpatialDE","text":"","code":"runSpatialDE(   exp_mat = NULL,   cell_ids = NULL,   spatial_distance = NULL,   adj_p.value = 0.05,   df = 3 )"},{"path":"https://github.com/jinming-cheng/SpNeigh/reference/RunSpatialDE.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Differential expression along spatial distance gradients using splines — runSpatialDE","text":"exp_mat normalized gene expression matrix (genes x cells), either matrix dgCMatrix. Typically log-normalized counts, e.g., Seurat object. cell_ids character vector cell IDs (column names exp_mat) used DE analysis. spatial_distance named numeric vector containing spatial distance (weights) cell. Must length cell_ids. Scaled distances recommended. adj_p.value Adjusted p-value threshold reporting differentially expressed genes. Default 0.05. df Integer. Degrees freedom spline basis. Default 3.","code":""},{"path":"https://github.com/jinming-cheng/SpNeigh/reference/RunSpatialDE.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Differential expression along spatial distance gradients using splines — runSpatialDE","text":"data frame differentially expressed genes, including: AveExpr, F, P.Value, adj.P.Val limma differential expression outputs Z1, Z2, Z3 Spline coefficients (Z1 typically corresponds linear trend) gene Gene name (exp_mat) trend \"Positive\" \"Negative\" trend based sign Z1 first spline coefficient (Z1) captures main expression trend along spatial distance.","code":""},{"path":"https://github.com/jinming-cheng/SpNeigh/reference/RunSpatialDE.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Differential expression along spatial distance gradients using splines — runSpatialDE","text":"","code":"# Load example data coords <- readRDS(system.file(\"extdata\", \"MouseBrainCoords.rds\",     package = \"SpNeigh\" )) logNorm_expr <- readRDS(system.file(\"extdata\", \"LogNormExpr.rds\",     package = \"SpNeigh\" ))  # Identify cluster-specific cells and compute spatial weights cells_c0 <- subset(coords, cluster == 0)$cell bon_c0 <- getBoundary(data = coords, one_cluster = 0) weights <- computeBoundaryWeights(     data = coords, cell_ids = cells_c0,     boundary = bon_c0 )  # Run spatial DE result <- runSpatialDE(     exp_mat = logNorm_expr, cell_ids = cells_c0,     spatial_distance = weights ) head(result) #>                Z1        Z2        Z3  AveExpr         F P.Value adj.P.Val #> Aldh1a2  90.19564 -72.83701  18.56803 1.642933 1156.7476       0         0 #> Car4    -86.85851  37.72830 -30.91311 3.007433  590.8437       0         0 #> Col1a1   84.54759 -60.30661  21.47013 1.675953  885.1705       0         0 #> Dcn     112.15109 -72.28618  28.47200 2.337544 1295.7527       0         0 #> Fmod     91.46180 -63.54536  20.99449 1.562370 1083.7186       0         0 #> Gjb2     67.07620 -52.43818  14.55533 1.193263  742.6493       0         0 #>            gene    trend #> Aldh1a2 Aldh1a2 Positive #> Car4       Car4 Negative #> Col1a1   Col1a1 Positive #> Dcn         Dcn Positive #> Fmod       Fmod Positive #> Gjb2       Gjb2 Positive"},{"path":"https://github.com/jinming-cheng/SpNeigh/reference/SafeColorPalette.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate a safe color palette for discrete clusters — safeColorPalette","title":"Generate a safe color palette for discrete clusters — safeColorPalette","text":"Returns vector visually distinct colors plotting discrete clusters. Uses colors15_cheng base palette. number clusters exceeds base palette, additional colors generated using scales::hue_pal().","code":""},{"path":"https://github.com/jinming-cheng/SpNeigh/reference/SafeColorPalette.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate a safe color palette for discrete clusters — safeColorPalette","text":"","code":"safeColorPalette(   n_clusters = NULL,   base_colors = colors15_cheng,   verbose = TRUE )"},{"path":"https://github.com/jinming-cheng/SpNeigh/reference/SafeColorPalette.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate a safe color palette for discrete clusters — safeColorPalette","text":"n_clusters Number unique clusters. base_colors character vector base colors. Default colors15_cheng. verbose Logical. TRUE, displays message extended colors used. Default TRUE.","code":""},{"path":"https://github.com/jinming-cheng/SpNeigh/reference/SafeColorPalette.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate a safe color palette for discrete clusters — safeColorPalette","text":"character vector colors length n_clusters.","code":""},{"path":"https://github.com/jinming-cheng/SpNeigh/reference/SafeColorPalette.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generate a safe color palette for discrete clusters — safeColorPalette","text":"","code":"safeColorPalette(5) #> [1] \"#6495ED\" \"#BF3EFF\" \"#FF3030\" \"#FFD700\" \"#ADFF2F\" safeColorPalette(20) #> Note: 15 base colors provided. Generated 5 additional colors using `scales::hue_pal()` (total = 20) to match 20 clusters. #>  [1] \"#6495ED\" \"#BF3EFF\" \"#FF3030\" \"#FFD700\" \"#ADFF2F\" \"#00FA9A\" \"#48D1CC\" #>  [8] \"#FFA500\" \"#FFC0CB\" \"#CD1076\" \"#EE82EE\" \"#FF00FF\" \"#8B6914\" \"#00FFFF\" #> [15] \"#E5E5E5\" \"#F8766D\" \"#A3A500\" \"#00BF7D\" \"#00B0F6\" \"#E76BF3\""},{"path":"https://github.com/jinming-cheng/SpNeigh/reference/SpNeigh-package.html","id":null,"dir":"Reference","previous_headings":"","what":"SpNeigh: Spatial Neighborhood Modeling and Differential Expression Analysis for Transcriptomics — SpNeigh-package","title":"SpNeigh: Spatial Neighborhood Modeling and Differential Expression Analysis for Transcriptomics — SpNeigh-package","text":"SpNeigh provides methods neighborhood-aware analysis spatial transcriptomics data. supports boundary detection, spatial weighting (centroid- boundary-based), spatially informed differential expression using spline-based models, spatial enrichment analysis via Spatial Enrichment Index (SEI). Designed compatibility Seurat objects, SpatialExperiment objects spatial data frames, SpNeigh enables interpretable, publication-ready analysis spatial gene expression patterns.","code":""},{"path":[]},{"path":"https://github.com/jinming-cheng/SpNeigh/reference/SpNeigh-package.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"SpNeigh: Spatial Neighborhood Modeling and Differential Expression Analysis for Transcriptomics — SpNeigh-package","text":"Maintainer: Jinming Cheng jinming.cheng@outlook.com (ORCID)","code":""},{"path":"https://github.com/jinming-cheng/SpNeigh/reference/SplineDesign.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate an orthonormal spline-based design matrix — splineDesign","title":"Generate an orthonormal spline-based design matrix — splineDesign","text":"Constructs orthonormal design matrix numeric covariate (e.g., spatial distance) using natural cubic spline basis. output matrix can used linear modeling capture smooth, non-linear trends along continuous variables.","code":""},{"path":"https://github.com/jinming-cheng/SpNeigh/reference/SplineDesign.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate an orthonormal spline-based design matrix — splineDesign","text":"","code":"splineDesign(x, df = 3)"},{"path":"https://github.com/jinming-cheng/SpNeigh/reference/SplineDesign.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate an orthonormal spline-based design matrix — splineDesign","text":"x numeric vector representing continuous covariate (e.g., distance pseudotime). df Integer. Degrees freedom spline basis. Default 3.","code":""},{"path":"https://github.com/jinming-cheng/SpNeigh/reference/SplineDesign.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate an orthonormal spline-based design matrix — splineDesign","text":"numeric matrix orthonormal columns (number rows x). columns represent smoothed trends extracted spline basis. first column directionally aligned input vector (x).","code":""},{"path":"https://github.com/jinming-cheng/SpNeigh/reference/SplineDesign.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Generate an orthonormal spline-based design matrix — splineDesign","text":"first column resulting matrix aligned show positive correlation input vector typically captures main linear monotonic trend.","code":""},{"path":"https://github.com/jinming-cheng/SpNeigh/reference/SplineDesign.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generate an orthonormal spline-based design matrix — splineDesign","text":"","code":"x <- seq(0, 1, length.out = 100) Z <- splineDesign(x) cor(Z[, 1], x) # Should be > 0 #> [1] 1  # Use Z in modeling y <- sin(2 * pi * x) + rnorm(100, sd = 0.2) fit <- lm(y ~ Z) summary(fit) #>  #> Call: #> lm(formula = y ~ Z) #>  #> Residuals: #>      Min       1Q   Median       3Q      Max  #> -0.45632 -0.12606 -0.01557  0.11582  0.52905  #>  #> Coefficients: #>              Estimate Std. Error t value Pr(>|t|)     #> (Intercept) -0.008342   0.019045  -0.438    0.662     #> Z1          -5.635501   0.190454 -29.590   <2e-16 *** #> Z2           3.591123   0.190454  18.856   <2e-16 *** #> Z3           2.891887   0.190454  15.184   <2e-16 *** #> --- #> Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1 #>  #> Residual standard error: 0.1905 on 96 degrees of freedom #> Multiple R-squared:  0.9384,\tAdjusted R-squared:  0.9364  #> F-statistic: 487.2 on 3 and 96 DF,  p-value: < 2.2e-16 #>"},{"path":"https://github.com/jinming-cheng/SpNeigh/reference/SplitBoundaryPolyByAnchor.html","id":null,"dir":"Reference","previous_headings":"","what":"Split a polygon boundary into two parts using anchor points — splitBoundaryPolyByAnchor","title":"Split a polygon boundary into two parts using anchor points — splitBoundaryPolyByAnchor","text":"function takes sf POLYGON object two anchor points (infers ) split polygon boundary two LINESTRING edge segments.","code":""},{"path":"https://github.com/jinming-cheng/SpNeigh/reference/SplitBoundaryPolyByAnchor.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Split a polygon boundary into two parts using anchor points — splitBoundaryPolyByAnchor","text":"","code":"splitBoundaryPolyByAnchor(boundary_poly = NULL, pt1 = NULL, pt2 = NULL)"},{"path":"https://github.com/jinming-cheng/SpNeigh/reference/SplitBoundaryPolyByAnchor.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Split a polygon boundary into two parts using anchor points — splitBoundaryPolyByAnchor","text":"boundary_poly sf POLYGON object. pt1 numeric vector length 2 (x, y) NULL. NULL, leftmost boundary point used. pt2 numeric vector length 2 (x, y) NULL. NULL, rightmost boundary point used.","code":""},{"path":"https://github.com/jinming-cheng/SpNeigh/reference/SplitBoundaryPolyByAnchor.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Split a polygon boundary into two parts using anchor points — splitBoundaryPolyByAnchor","text":"sf object two LINESTRING features 'region_id' column indicating edge1 edge2.","code":""},{"path":"https://github.com/jinming-cheng/SpNeigh/reference/SplitBoundaryPolyByAnchor.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Split a polygon boundary into two parts using anchor points — splitBoundaryPolyByAnchor","text":"","code":"# Load coordinates coords <- readRDS(system.file(\"extdata\", \"MouseBrainCoords.rds\",     package = \"SpNeigh\" )) head(coords) #>          x        y cell cluster #> 1 1898.815 2540.963    1       4 #> 2 1895.305 2532.627    2       4 #> 3 2368.073 2534.409    3       2 #> 4 1903.726 2560.010    4       4 #> 5 1917.481 2543.132    5       4 #> 6 1926.540 2560.044    6       4  # Build boundary polygons from the boundary points boundary_points <- getBoundary(     data = coords, one_cluster = 2,     subregion_method = \"dbscan\",     eps = 120, minPts = 10 ) boundary_polys <- buildBoundaryPoly(boundary_points)  # Split boundary polygon 1 into two edges using leftmost # and rightmost anchor points boundary_edges <- splitBoundaryPolyByAnchor(boundary_polys[1, ]) plot(boundary_edges, lwd = 2)   # Split boundary polygon 1 into two edges using two anchor points pt1 <- c(4000, 1500) pt2 <- c(2000, 3000) boundary_edges <- splitBoundaryPolyByAnchor(boundary_polys[1, ],     pt1 = pt1,     pt2 = pt2 ) plot(boundary_edges, lwd = 2)"},{"path":"https://github.com/jinming-cheng/SpNeigh/reference/StatsCellsInside.html","id":null,"dir":"Reference","previous_headings":"","what":"Summarize cell counts and proportions inside spatial regions — statsCellsInside","title":"Summarize cell counts and proportions inside spatial regions — statsCellsInside","text":"Computes number proportion cells cluster inside boundaries ring regions. function useful downstream visualizations bar plots pie charts showing spatial composition cell types per region.","code":""},{"path":"https://github.com/jinming-cheng/SpNeigh/reference/StatsCellsInside.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Summarize cell counts and proportions inside spatial regions — statsCellsInside","text":"","code":"statsCellsInside(cells_inside = NULL)"},{"path":"https://github.com/jinming-cheng/SpNeigh/reference/StatsCellsInside.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Summarize cell counts and proportions inside spatial regions — statsCellsInside","text":"cells_inside sf object cells returned getCellsInside(). Must contain cluster region_id columns.","code":""},{"path":"https://github.com/jinming-cheng/SpNeigh/reference/StatsCellsInside.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Summarize cell counts and proportions inside spatial regions — statsCellsInside","text":"data frame one row per cluster per region, containing following columns: region_id: Identifier spatial region. cluster: Cluster label cells. count: Number cells given cluster region. proportion: Proportion cells given cluster relative total number cells region.","code":""},{"path":"https://github.com/jinming-cheng/SpNeigh/reference/StatsCellsInside.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Summarize cell counts and proportions inside spatial regions — statsCellsInside","text":"","code":"# Load coordinates data coords <- readRDS(system.file(\"extdata\", \"MouseBrainCoords.rds\",     package = \"SpNeigh\" ))  # Get boundary and cells inside boundary_points <- getBoundary(     data = coords, one_cluster = 2,     eps = 120, minPts = 10 ) cells_inside <- getCellsInside(data = coords, boundary = boundary_points)  # Summarize cluster statistics per region stats_cells <- statsCellsInside(cells_inside) head(stats_cells) #> # A tibble: 6 × 4 #>   region_id cluster count proportion #>   <chr>     <fct>   <int>      <dbl> #> 1 1         0         456   0.102    #> 2 1         2        3144   0.700    #> 3 1         3         132   0.0294   #> 4 1         4         134   0.0299   #> 5 1         5           3   0.000668 #> 6 1         6          34   0.00757"},{"path":"https://github.com/jinming-cheng/SpNeigh/reference/colors15_cheng.html","id":null,"dir":"Reference","previous_headings":"","what":"Custom Color Palette — colors15_cheng","title":"Custom Color Palette — colors15_cheng","text":"character vector containing 15 colors.","code":""},{"path":"https://github.com/jinming-cheng/SpNeigh/reference/colors15_cheng.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Custom Color Palette — colors15_cheng","text":"","code":"colors15_cheng"},{"path":"https://github.com/jinming-cheng/SpNeigh/reference/colors15_cheng.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Custom Color Palette — colors15_cheng","text":"character vector length 15.","code":""},{"path":"https://github.com/jinming-cheng/SpNeigh/reference/colors15_cheng.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Custom Color Palette — colors15_cheng","text":"","code":"plot(1:15, 1:15, pch = 16, col = colors15_cheng)  barplot(rep(1, 15), col = colors15_cheng)"},{"path":"https://github.com/jinming-cheng/SpNeigh/reference/theme_spneigh.html","id":null,"dir":"Reference","previous_headings":"","what":"Custom ggplot2 theme — theme_spneigh","title":"Custom ggplot2 theme — theme_spneigh","text":"Provides consistent clean visual style plots generated within package. theme builds theme_classic() adjusts text sizes margins better readability figures.","code":""},{"path":"https://github.com/jinming-cheng/SpNeigh/reference/theme_spneigh.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Custom ggplot2 theme — theme_spneigh","text":"","code":"theme_spneigh()"},{"path":"https://github.com/jinming-cheng/SpNeigh/reference/theme_spneigh.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Custom ggplot2 theme — theme_spneigh","text":"ggplot2 theme object can added ggplot visualizations.","code":""},{"path":"https://github.com/jinming-cheng/SpNeigh/reference/theme_spneigh.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Custom ggplot2 theme — theme_spneigh","text":"","code":"library(ggplot2) ggplot(mtcars, aes(mpg, wt)) +     geom_point() +     theme_spneigh()"},{"path":"https://github.com/jinming-cheng/SpNeigh/news/index.html","id":"spneigh-0990","dir":"Changelog","previous_headings":"","what":"SpNeigh 0.99.0","title":"SpNeigh 0.99.0","text":"Initial Bioconductor submission","code":""},{"path":"https://github.com/jinming-cheng/SpNeigh/news/index.html","id":"new-features-0-99-0","dir":"Changelog","previous_headings":"","what":"New Features","title":"SpNeigh 0.99.0","text":"Introduced RunSpatialDE() function spatial differential expression using spatial weights. Added ComputeSpatialEnrichmentIndex() enrichment quantification. Implemented GetBoundary(), GetRingRegion(), RemoveOutliers() spatial region detection. Added PlotSpatialExpression() visualization tools.","code":""}]
