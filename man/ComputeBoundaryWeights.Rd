% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/ComputeWeights.R
\name{ComputeBoundaryWeights}
\alias{ComputeBoundaryWeights}
\title{Compute Spatial Weights Based on Distance to Nearest Polygon Boundary}
\usage{
ComputeBoundaryWeights(
  data = NULL,
  cell_ids = NULL,
  boundary = NULL,
  scale = TRUE,
  method = c("inverse", "gaussian", "linear", "quadratic"),
  sigma = 0.5
)
}
\arguments{
\item{data}{A data frame or Seurat object containng at least three columns: \code{x}, \code{y} and \code{cell}.}

\item{cell_ids}{A vector of cell IDs to subset from data.}

\item{boundary}{An \code{sf} object containing polygon boundaries (e.g. rings).}

\item{scale}{A logical value indicating whether to scale distances to [0, 1] before computing weights. Scaling is recommended, and default is TRUE.}

\item{method}{A string specifying the decay method. One of \code{"inverse"},
\code{"gaussian"}, \code{"linear"}, or \code{"quadratic"}.}

\item{sigma}{Standard deviation for the Gaussian decay function. Default is 0.5 for scaled distance. If \code{scale = FALSE}, choose a value that is about half the regionâ€™s width.}
}
\value{
A named numeric vector of weights, one per cell in \code{cell_ids}.
}
\description{
This function assigns each cell to the nearest polygon boundary and computes
a spatial weight based on its distance to that boundary. Supports inverse,
Gaussian, linear, and quadratic decay methods.
}
\examples{
# Load coordinates
coords <- readRDS(system.file("extdata", "MouseBrainCoords.rds",
                              package = "SpNeigh"))
head(coords)

# Get boundaries for cells in cluster 2
boundary_points <- GetBoundary(data = coords, one_cluster = 2)
boundary_polys <- BuildBoundaryPoly(boundary_points)

# Plot boundary regions
PlotRegion(boundary_polys)

# Compute spatial weights to the boundary of region 1 for cells in cluster 2
cells_c2 <- subset(coords, cluster==2)[,"cell"]
weights <- ComputeBoundaryWeights(data = coords, cell_ids = cells_c2,
                                  boundary = boundary_polys[1,])
weights[1:3]
}
