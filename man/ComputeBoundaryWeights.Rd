% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/ComputeWeights.R
\name{ComputeBoundaryWeights}
\alias{ComputeBoundaryWeights}
\title{Compute spatial weights based on distance to nearest boundary}
\usage{
ComputeBoundaryWeights(
  data = NULL,
  cell_ids = NULL,
  boundary = NULL,
  scale = TRUE,
  method = c("inverse", "gaussian", "linear", "quadratic"),
  sigma = 0.5
)
}
\arguments{
\item{data}{A data frame, Seurat object or SpatialExperiment object
containing spatial coordinates.
Must include columns: \code{cell}, \code{x}, and \code{y}.}

\item{cell_ids}{A character vector of cell IDs to use for weight computation.}

\item{boundary}{Either an \code{sf} object containing boundary
geometries (\code{POLYGON} or \code{LINESTRING}),
or a data frame of boundary points
returned from \code{GetBoundary()}.}

\item{scale}{Logical. Whether to scale distances to the range [0, 1]
before applying decay functions. Default is \code{TRUE}.}

\item{method}{Decay function to convert distances to weights.
One of: "inverse", "gaussian", "linear", or "quadratic".}

\item{sigma}{Standard deviation for the Gaussian decay
(used only if \code{method = "gaussian"}).
Default is \code{0.5} (recommended for scaled distances).}
}
\value{
A named numeric vector of weights, with names corresponding
to \code{cell_ids}.
}
\description{
Computes spatial weights for a subset of cells based on their Euclidean
distance to the nearest boundary segment. This method supports both
closed boundary polygons and open boundary edges (e.g., LINESTRINGs),
and is useful for modeling proximity-based enrichment near anatomical
or user-defined regions.
}
\details{
Supports multiple decay methods for converting distance into weights.
Optionally scales distances to the [0, 1] range before computing weights.
}
\examples{
# Load spatial coordinates
coords <- readRDS(system.file("extdata", "MouseBrainCoords.rds",
    package = "SpNeigh"
))

# Get and build boundary polygons from cluster 2
boundary_points <- GetBoundary(data = coords, one_cluster = 2)
boundary_polys <- BuildBoundaryPoly(boundary_points)

# Compute weights to polygon boundary
cells_c2 <- subset(coords, cluster == 2)$cell
weights <- ComputeBoundaryWeights(
    data = coords, cell_ids = cells_c2,
    boundary = boundary_polys[1, ]
)

# Compute weights to a specific boundary edge
boundary_edges <- SplitBoundaryPolyByAnchor(boundary_polys[1, ])
weights_edge <- ComputeBoundaryWeights(
    data = coords, cell_ids = cells_c2,
    boundary = boundary_edges[2, ]
)

}
