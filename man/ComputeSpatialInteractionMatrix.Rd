% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/ComputeSpatialInteractionMatrix.R
\name{computeSpatialInteractionMatrix}
\alias{computeSpatialInteractionMatrix}
\title{Compute a spatial neighborhood interaction matrix using
K-nearest neighbors (KNN)}
\usage{
computeSpatialInteractionMatrix(data = NULL, cluster_col = NULL, k = 10)
}
\arguments{
\item{data}{A \code{Seurat} object, a \code{SpatialExperiment} object,
or a data frame containing spatial coordinates.}

\item{cluster_col}{Character scalar specifying the metadata column name
containing cluster assignments. If \code{NULL}, a default is used
depending on the input object type:
\itemize{
\item \code{"seurat_clusters"} for \code{Seurat} objects
\item \code{"cluster"} for \code{SpatialExperiment} objects
}}

\item{k}{Integer. Number of nearest neighbors to use for each cell.
Default is 10.}
}
\value{
A numeric matrix where rows represent focal clusters and columns
represent neighboring clusters. Each cell in the matrix indicates
how frequently a neighbor cluster appears among the k-nearest
neighbors of cells from the focal cluster.
}
\description{
Computes a spatial interaction matrix where each entry quantifies
the number of neighboring cells from a given cluster (columns) that are
among the \code{k}-nearest neighbors of cells in another cluster (rows).
This provides a summary of spatial proximity and enrichment of
neighboring clusters around each focal cluster.
}
\details{
The matrix is built by identifying the \code{k} nearest neighbors for each cell
based on spatial coordinates, and then tabulating the cluster identities
of those neighbors with respect to the cluster identity of the focal cell.
}
\examples{
# Load coordinates
coords <- readRDS(system.file("extdata", "MouseBrainCoords.rds",
    package = "SpNeigh"
))

# Compute interaction matrix using all cells
interaction_matrix <- computeSpatialInteractionMatrix(coords)
head(interaction_matrix)

# Compute interaction matrix for cells inside boundaries
boundary_points <- getBoundary(
    data = coords, one_cluster = 2,
    eps = 120, minPts = 10
)
cells_inside <- getCellsInside(data = coords, boundary = boundary_points)
coords_sub <- subset(coords, cell \%in\% cells_inside$cell)
computeSpatialInteractionMatrix(coords_sub)

# Compute interaction matrix for cells inside ring region 2
ring_regions <- getRingRegion(boundary = boundary_points, dist = 100)
cells_ring <- getCellsInside(data = coords, boundary = ring_regions[2, ])
coords_sub <- subset(coords, cell \%in\% cells_ring$cell)
computeSpatialInteractionMatrix(coords_sub)

}
